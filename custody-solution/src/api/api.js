"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Qredo Partner & Core Client API
 * The Qredo Partner API provisions and manages Qredo services. It can be used by Partners to setup and manage client accounts. The Core Client API enables transactions to be initiated and signed. <br>   Note, two servers are provided:   - API Server base path https://api.qredo.network/api/v1/p   - Sandbox server base path https://sandbox-api.qredo.network/api/v1/p
 *
 * The version of the OpenAPI document: 1.1.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SweepApiFactory = exports.SweepApiFp = exports.SweepApiAxiosParamCreator = exports.LiquidityHubApi = exports.LiquidityHubApiFactory = exports.LiquidityHubApiFp = exports.LiquidityHubApiAxiosParamCreator = exports.HoldingApi = exports.HoldingApiFactory = exports.HoldingApiFp = exports.HoldingApiAxiosParamCreator = exports.FundApi = exports.FundApiFactory = exports.FundApiFp = exports.FundApiAxiosParamCreator = exports.CoreClientSignApi = exports.CoreClientSignApiFactory = exports.CoreClientSignApiFp = exports.CoreClientSignApiAxiosParamCreator = exports.CoreClientApi = exports.CoreClientApiFactory = exports.CoreClientApiFp = exports.CoreClientApiAxiosParamCreator = exports.CompanyApi = exports.CompanyApiFactory = exports.CompanyApiFp = exports.CompanyApiAxiosParamCreator = exports.CommonApi = exports.CommonApiFactory = exports.CommonApiFp = exports.CommonApiAxiosParamCreator = exports.AutomatedApproverApi = exports.AutomatedApproverApiFactory = exports.AutomatedApproverApiFp = exports.AutomatedApproverApiAxiosParamCreator = exports.AtomicSwapApi = exports.AtomicSwapApiFactory = exports.AtomicSwapApiFp = exports.AtomicSwapApiAxiosParamCreator = exports.TxIdStatusEnum = exports.TxHistoryItemTypeEnum = exports.TxHistoryItemStatusEnum = exports.SwapTxIdStatusEnum = exports.FeesRequestTypeEnum = exports.EntityType = exports.CoreClientWalletStatusEnum = exports.ActionInfoStatusEnum = exports.ActionInfoTypeEnum = exports.ActionDetailsStatusEnum = exports.ActionDetailsTypeEnum = void 0;
exports.WithdrawalApi = exports.WithdrawalApiFactory = exports.WithdrawalApiFp = exports.WithdrawalApiAxiosParamCreator = exports.WalletApi = exports.WalletApiFactory = exports.WalletApiFp = exports.WalletApiAxiosParamCreator = exports.TrustedNetworkApi = exports.TrustedNetworkApiFactory = exports.TrustedNetworkApiFp = exports.TrustedNetworkApiAxiosParamCreator = exports.TransferApi = exports.TransferApiFactory = exports.TransferApiFp = exports.TransferApiAxiosParamCreator = exports.SweepApi = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.ActionDetailsTypeEnum = {
    ApproveWithdraw: 'ApproveWithdraw',
    ApproveTransfer: 'ApproveTransfer'
};
exports.ActionDetailsStatusEnum = {
    Pending: 'pending',
    Expired: 'expired',
    Approved: 'approved',
    Rejected: 'rejected'
};
exports.ActionInfoTypeEnum = {
    ApproveWithdraw: 'ApproveWithdraw',
    ApproveTransfer: 'ApproveTransfer'
};
exports.ActionInfoStatusEnum = {
    Pending: 'pending',
    Expired: 'expired',
    Approved: 'approved',
    Rejected: 'rejected'
};
exports.CoreClientWalletStatusEnum = {
    Pending: 'pending',
    Expired: 'expired',
    Approved: 'approved',
    Rejected: 'rejected'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.EntityType = {
    User: 'user',
    Company: 'company',
    CoreClient: 'core-client'
};
exports.FeesRequestTypeEnum = {
    Withdraw: 'withdraw',
    TransferOut: 'transferOut',
    Swap: 'swap'
};
exports.SwapTxIdStatusEnum = {
    New: 'new',
    Existing: 'existing'
};
exports.TxHistoryItemStatusEnum = {
    PendingInitiate: 'pending_initiate',
    Pending: 'pending',
    Expired: 'expired',
    Approved: 'approved',
    InitiateRejected: 'initiate_rejected',
    CustodyRejected: 'custody_rejected',
    ChainRejected: 'chain_rejected',
    TakerPending: 'taker_pending',
    TakerApproved: 'taker_approved'
};
exports.TxHistoryItemTypeEnum = {
    None: 'none',
    Deposit: 'deposit',
    Withdraw: 'withdraw',
    TransferIn: 'transferIn',
    TransferOut: 'transferOut',
    Swap: 'swap',
    SwapIn: 'swapIn',
    SwapOut: 'swapOut'
};
exports.TxIdStatusEnum = {
    New: 'new',
    Existing: 'existing'
};
/**
 * AtomicSwapApi - axios parameter creator
 * @export
 */
const AtomicSwapApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Initiate an Atomic Swap Quote and set parameters for the transaction.
         * @summary Create Atomic Swap Quote
         * @param {string} companyId
         * @param {AtomicSwapMake} atomicSwapMake
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakePost: (companyId, atomicSwapMake, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdAtomicswapMakePost', 'companyId', companyId);
            // verify required parameter 'atomicSwapMake' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdAtomicswapMakePost', 'atomicSwapMake', atomicSwapMake);
            const localVarPath = `/company/{company_id}/atomicswap/make`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(atomicSwapMake, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Cancel atomic swap
         * @summary Cancel Atomic Swap
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakeTxIdDelete: (companyId, txId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdAtomicswapMakeTxIdDelete', 'companyId', companyId);
            // verify required parameter 'txId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdAtomicswapMakeTxIdDelete', 'txId', txId);
            const localVarPath = `/company/{company_id}/atomicswap/make/{tx_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Obtain details on an atomic swap
         * @summary Get Atomic Swaps Quote details
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakeTxIdGet: (companyId, txId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdAtomicswapMakeTxIdGet', 'companyId', companyId);
            // verify required parameter 'txId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdAtomicswapMakeTxIdGet', 'txId', txId);
            const localVarPath = `/company/{company_id}/atomicswap/make/{tx_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Initiate an atomic swap take transaction.
         * @summary Initiate Atomic swap taker transaction
         * @param {string} companyId
         * @param {AtomicSwapTake} atomicSwapTake
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapTakePost: (companyId, atomicSwapTake, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdAtomicswapTakePost', 'companyId', companyId);
            // verify required parameter 'atomicSwapTake' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdAtomicswapTakePost', 'atomicSwapTake', atomicSwapTake);
            const localVarPath = `/company/{company_id}/atomicswap/take`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(atomicSwapTake, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Obtain details on an atomic swap
         * @summary Get atomic swap taker status
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapTakeTxIdGet: (companyId, txId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdAtomicswapTakeTxIdGet', 'companyId', companyId);
            // verify required parameter 'txId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdAtomicswapTakeTxIdGet', 'txId', txId);
            const localVarPath = `/company/{company_id}/atomicswap/take/{tx_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AtomicSwapApiAxiosParamCreator = AtomicSwapApiAxiosParamCreator;
/**
 * AtomicSwapApi - functional programming interface
 * @export
 */
const AtomicSwapApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AtomicSwapApiAxiosParamCreator)(configuration);
    return {
        /**
         * Initiate an Atomic Swap Quote and set parameters for the transaction.
         * @summary Create Atomic Swap Quote
         * @param {string} companyId
         * @param {AtomicSwapMake} atomicSwapMake
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakePost(companyId, atomicSwapMake, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdAtomicswapMakePost(companyId, atomicSwapMake, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Cancel atomic swap
         * @summary Cancel Atomic Swap
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakeTxIdDelete(companyId, txId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdAtomicswapMakeTxIdDelete(companyId, txId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Obtain details on an atomic swap
         * @summary Get Atomic Swaps Quote details
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdAtomicswapMakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Initiate an atomic swap take transaction.
         * @summary Initiate Atomic swap taker transaction
         * @param {string} companyId
         * @param {AtomicSwapTake} atomicSwapTake
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapTakePost(companyId, atomicSwapTake, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdAtomicswapTakePost(companyId, atomicSwapTake, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Obtain details on an atomic swap
         * @summary Get atomic swap taker status
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapTakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdAtomicswapTakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AtomicSwapApiFp = AtomicSwapApiFp;
/**
 * AtomicSwapApi - factory interface
 * @export
 */
const AtomicSwapApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AtomicSwapApiFp)(configuration);
    return {
        /**
         * Initiate an Atomic Swap Quote and set parameters for the transaction.
         * @summary Create Atomic Swap Quote
         * @param {string} companyId
         * @param {AtomicSwapMake} atomicSwapMake
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakePost(companyId, atomicSwapMake, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdAtomicswapMakePost(companyId, atomicSwapMake, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel atomic swap
         * @summary Cancel Atomic Swap
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakeTxIdDelete(companyId, txId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdAtomicswapMakeTxIdDelete(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain details on an atomic swap
         * @summary Get Atomic Swaps Quote details
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdAtomicswapMakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate an atomic swap take transaction.
         * @summary Initiate Atomic swap taker transaction
         * @param {string} companyId
         * @param {AtomicSwapTake} atomicSwapTake
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapTakePost(companyId, atomicSwapTake, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdAtomicswapTakePost(companyId, atomicSwapTake, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain details on an atomic swap
         * @summary Get atomic swap taker status
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapTakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdAtomicswapTakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AtomicSwapApiFactory = AtomicSwapApiFactory;
/**
 * AtomicSwapApi - object-oriented interface
 * @export
 * @class AtomicSwapApi
 * @extends {BaseAPI}
 */
class AtomicSwapApi extends base_1.BaseAPI {
    /**
     * Initiate an Atomic Swap Quote and set parameters for the transaction.
     * @summary Create Atomic Swap Quote
     * @param {string} companyId
     * @param {AtomicSwapMake} atomicSwapMake
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicSwapApi
     */
    companyCompanyIdAtomicswapMakePost(companyId, atomicSwapMake, xNonce, xTimestamp, xSign, options) {
        return (0, exports.AtomicSwapApiFp)(this.configuration).companyCompanyIdAtomicswapMakePost(companyId, atomicSwapMake, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cancel atomic swap
     * @summary Cancel Atomic Swap
     * @param {string} companyId
     * @param {string} txId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicSwapApi
     */
    companyCompanyIdAtomicswapMakeTxIdDelete(companyId, txId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.AtomicSwapApiFp)(this.configuration).companyCompanyIdAtomicswapMakeTxIdDelete(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Obtain details on an atomic swap
     * @summary Get Atomic Swaps Quote details
     * @param {string} companyId
     * @param {string} txId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicSwapApi
     */
    companyCompanyIdAtomicswapMakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.AtomicSwapApiFp)(this.configuration).companyCompanyIdAtomicswapMakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Initiate an atomic swap take transaction.
     * @summary Initiate Atomic swap taker transaction
     * @param {string} companyId
     * @param {AtomicSwapTake} atomicSwapTake
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicSwapApi
     */
    companyCompanyIdAtomicswapTakePost(companyId, atomicSwapTake, xNonce, xTimestamp, xSign, options) {
        return (0, exports.AtomicSwapApiFp)(this.configuration).companyCompanyIdAtomicswapTakePost(companyId, atomicSwapTake, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Obtain details on an atomic swap
     * @summary Get atomic swap taker status
     * @param {string} companyId
     * @param {string} txId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicSwapApi
     */
    companyCompanyIdAtomicswapTakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.AtomicSwapApiFp)(this.configuration).companyCompanyIdAtomicswapTakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AtomicSwapApi = AtomicSwapApi;
/**
 * AutomatedApproverApi - axios parameter creator
 * @export
 */
const AutomatedApproverApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Finishes core client registration by storing the signed IDDoc
         * @summary Finish core client onboarding
         * @param {CoreclientFinishPostRequest} coreclientFinishPostRequest
         * @param {string} [xApiXkp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientFinishPost: (coreclientFinishPostRequest, xApiXkp, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'coreclientFinishPostRequest' is not null or undefined
            (0, common_1.assertParamExists)('coreclientFinishPost', 'coreclientFinishPostRequest', coreclientFinishPostRequest);
            const localVarPath = `/coreclient/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xApiXkp != null) {
                localVarHeaderParameter['x-api-xkp'] = String(xApiXkp);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(coreclientFinishPostRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Initiates an automated approver core client registration
         * @summary Initiate core client onboarding
         * @param {Request} request
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientInitPost: (request, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'request' is not null or undefined
            (0, common_1.assertParamExists)('coreclientInitPost', 'request', request);
            const localVarPath = `/coreclient/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(request, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Reject action_id
         * @summary Reject action
         * @param {string} actionId
         * @param {string} [xApiZkp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoreclientActionActionId: (actionId, xApiZkp, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            (0, common_1.assertParamExists)('deleteCoreclientActionActionId', 'actionId', actionId);
            const localVarPath = `/coreclient/action/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xApiZkp != null) {
                localVarHeaderParameter['x-api-zkp'] = String(xApiZkp);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns action messages for action_id
         * @summary Get action messages
         * @param {string} actionId
         * @param {string} [xApiZkp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreclientActionActionId: (actionId, xApiZkp, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            (0, common_1.assertParamExists)('getCoreclientActionActionId', 'actionId', actionId);
            const localVarPath = `/coreclient/action/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xApiZkp != null) {
                localVarHeaderParameter['x-api-zkp'] = String(xApiZkp);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * WebSocket feed for core client actions
         * @summary Get core client actions feed
         * @param {string} [xApiZkp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreclientFeed: (xApiZkp, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/coreclient/feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xApiZkp != null) {
                localVarHeaderParameter['x-api-zkp'] = String(xApiZkp);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Approve acction_id
         * @summary Approve action
         * @param {string} actionId
         * @param {string} [xApiZkp]
         * @param {PutCoreclientActionActionIdRequest} [putCoreclientActionActionIdRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCoreclientActionActionId: (actionId, xApiZkp, putCoreclientActionActionIdRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            (0, common_1.assertParamExists)('putCoreclientActionActionId', 'actionId', actionId);
            const localVarPath = `/coreclient/action/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xApiZkp != null) {
                localVarHeaderParameter['x-api-zkp'] = String(xApiZkp);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(putCoreclientActionActionIdRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AutomatedApproverApiAxiosParamCreator = AutomatedApproverApiAxiosParamCreator;
/**
 * AutomatedApproverApi - functional programming interface
 * @export
 */
const AutomatedApproverApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AutomatedApproverApiAxiosParamCreator)(configuration);
    return {
        /**
         * Finishes core client registration by storing the signed IDDoc
         * @summary Finish core client onboarding
         * @param {CoreclientFinishPostRequest} coreclientFinishPostRequest
         * @param {string} [xApiXkp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientFinishPost(coreclientFinishPostRequest, xApiXkp, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientFinishPost(coreclientFinishPostRequest, xApiXkp, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Initiates an automated approver core client registration
         * @summary Initiate core client onboarding
         * @param {Request} request
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientInitPost(request, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientInitPost(request, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Reject action_id
         * @summary Reject action
         * @param {string} actionId
         * @param {string} [xApiZkp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoreclientActionActionId(actionId, xApiZkp, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCoreclientActionActionId(actionId, xApiZkp, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns action messages for action_id
         * @summary Get action messages
         * @param {string} actionId
         * @param {string} [xApiZkp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreclientActionActionId(actionId, xApiZkp, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCoreclientActionActionId(actionId, xApiZkp, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * WebSocket feed for core client actions
         * @summary Get core client actions feed
         * @param {string} [xApiZkp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreclientFeed(xApiZkp, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCoreclientFeed(xApiZkp, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Approve acction_id
         * @summary Approve action
         * @param {string} actionId
         * @param {string} [xApiZkp]
         * @param {PutCoreclientActionActionIdRequest} [putCoreclientActionActionIdRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCoreclientActionActionId(actionId, xApiZkp, putCoreclientActionActionIdRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.putCoreclientActionActionId(actionId, xApiZkp, putCoreclientActionActionIdRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AutomatedApproverApiFp = AutomatedApproverApiFp;
/**
 * AutomatedApproverApi - factory interface
 * @export
 */
const AutomatedApproverApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AutomatedApproverApiFp)(configuration);
    return {
        /**
         * Finishes core client registration by storing the signed IDDoc
         * @summary Finish core client onboarding
         * @param {CoreclientFinishPostRequest} coreclientFinishPostRequest
         * @param {string} [xApiXkp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientFinishPost(coreclientFinishPostRequest, xApiXkp, options) {
            return localVarFp.coreclientFinishPost(coreclientFinishPostRequest, xApiXkp, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates an automated approver core client registration
         * @summary Initiate core client onboarding
         * @param {Request} request
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientInitPost(request, xNonce, xTimestamp, xSign, options) {
            return localVarFp.coreclientInitPost(request, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Reject action_id
         * @summary Reject action
         * @param {string} actionId
         * @param {string} [xApiZkp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoreclientActionActionId(actionId, xApiZkp, options) {
            return localVarFp.deleteCoreclientActionActionId(actionId, xApiZkp, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns action messages for action_id
         * @summary Get action messages
         * @param {string} actionId
         * @param {string} [xApiZkp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreclientActionActionId(actionId, xApiZkp, options) {
            return localVarFp.getCoreclientActionActionId(actionId, xApiZkp, options).then((request) => request(axios, basePath));
        },
        /**
         * WebSocket feed for core client actions
         * @summary Get core client actions feed
         * @param {string} [xApiZkp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreclientFeed(xApiZkp, options) {
            return localVarFp.getCoreclientFeed(xApiZkp, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve acction_id
         * @summary Approve action
         * @param {string} actionId
         * @param {string} [xApiZkp]
         * @param {PutCoreclientActionActionIdRequest} [putCoreclientActionActionIdRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCoreclientActionActionId(actionId, xApiZkp, putCoreclientActionActionIdRequest, options) {
            return localVarFp.putCoreclientActionActionId(actionId, xApiZkp, putCoreclientActionActionIdRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AutomatedApproverApiFactory = AutomatedApproverApiFactory;
/**
 * AutomatedApproverApi - object-oriented interface
 * @export
 * @class AutomatedApproverApi
 * @extends {BaseAPI}
 */
class AutomatedApproverApi extends base_1.BaseAPI {
    /**
     * Finishes core client registration by storing the signed IDDoc
     * @summary Finish core client onboarding
     * @param {CoreclientFinishPostRequest} coreclientFinishPostRequest
     * @param {string} [xApiXkp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomatedApproverApi
     */
    coreclientFinishPost(coreclientFinishPostRequest, xApiXkp, options) {
        return (0, exports.AutomatedApproverApiFp)(this.configuration).coreclientFinishPost(coreclientFinishPostRequest, xApiXkp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Initiates an automated approver core client registration
     * @summary Initiate core client onboarding
     * @param {Request} request
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomatedApproverApi
     */
    coreclientInitPost(request, xNonce, xTimestamp, xSign, options) {
        return (0, exports.AutomatedApproverApiFp)(this.configuration).coreclientInitPost(request, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Reject action_id
     * @summary Reject action
     * @param {string} actionId
     * @param {string} [xApiZkp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomatedApproverApi
     */
    deleteCoreclientActionActionId(actionId, xApiZkp, options) {
        return (0, exports.AutomatedApproverApiFp)(this.configuration).deleteCoreclientActionActionId(actionId, xApiZkp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns action messages for action_id
     * @summary Get action messages
     * @param {string} actionId
     * @param {string} [xApiZkp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomatedApproverApi
     */
    getCoreclientActionActionId(actionId, xApiZkp, options) {
        return (0, exports.AutomatedApproverApiFp)(this.configuration).getCoreclientActionActionId(actionId, xApiZkp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * WebSocket feed for core client actions
     * @summary Get core client actions feed
     * @param {string} [xApiZkp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomatedApproverApi
     */
    getCoreclientFeed(xApiZkp, options) {
        return (0, exports.AutomatedApproverApiFp)(this.configuration).getCoreclientFeed(xApiZkp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Approve acction_id
     * @summary Approve action
     * @param {string} actionId
     * @param {string} [xApiZkp]
     * @param {PutCoreclientActionActionIdRequest} [putCoreclientActionActionIdRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomatedApproverApi
     */
    putCoreclientActionActionId(actionId, xApiZkp, putCoreclientActionActionIdRequest, options) {
        return (0, exports.AutomatedApproverApiFp)(this.configuration).putCoreclientActionActionId(actionId, xApiZkp, putCoreclientActionActionIdRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AutomatedApproverApi = AutomatedApproverApi;
/**
 * CommonApi - axios parameter creator
 * @export
 */
const CommonApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * returns a list of supported assets and their codes
         * @summary Supported assets
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsGet: (xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Calculate fees for specific assets and transaction types for any company on the network.
         * @summary Calculate fees
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {FeesRequest} [feesRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesPost: (xNonce, xTimestamp, xSign, feesRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(feesRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CommonApiAxiosParamCreator = CommonApiAxiosParamCreator;
/**
 * CommonApi - functional programming interface
 * @export
 */
const CommonApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CommonApiAxiosParamCreator)(configuration);
    return {
        /**
         * returns a list of supported assets and their codes
         * @summary Supported assets
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsGet(xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.assetsGet(xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Calculate fees for specific assets and transaction types for any company on the network.
         * @summary Calculate fees
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {FeesRequest} [feesRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesPost(xNonce, xTimestamp, xSign, feesRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.feesPost(xNonce, xTimestamp, xSign, feesRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CommonApiFp = CommonApiFp;
/**
 * CommonApi - factory interface
 * @export
 */
const CommonApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CommonApiFp)(configuration);
    return {
        /**
         * returns a list of supported assets and their codes
         * @summary Supported assets
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsGet(xNonce, xTimestamp, xSign, options) {
            return localVarFp.assetsGet(xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculate fees for specific assets and transaction types for any company on the network.
         * @summary Calculate fees
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {FeesRequest} [feesRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesPost(xNonce, xTimestamp, xSign, feesRequest, options) {
            return localVarFp.feesPost(xNonce, xTimestamp, xSign, feesRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CommonApiFactory = CommonApiFactory;
/**
 * CommonApi - object-oriented interface
 * @export
 * @class CommonApi
 * @extends {BaseAPI}
 */
class CommonApi extends base_1.BaseAPI {
    /**
     * returns a list of supported assets and their codes
     * @summary Supported assets
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonApi
     */
    assetsGet(xNonce, xTimestamp, xSign, options) {
        return (0, exports.CommonApiFp)(this.configuration).assetsGet(xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Calculate fees for specific assets and transaction types for any company on the network.
     * @summary Calculate fees
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {FeesRequest} [feesRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonApi
     */
    feesPost(xNonce, xTimestamp, xSign, feesRequest, options) {
        return (0, exports.CommonApiFp)(this.configuration).feesPost(xNonce, xTimestamp, xSign, feesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CommonApi = CommonApi;
/**
 * CompanyApi - axios parameter creator
 * @export
 */
const CompanyApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * returns details of a Company from the Company ID.
         * @summary Get Company
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdGet: (companyId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdGet', 'companyId', companyId);
            const localVarPath = `/company/{company_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Change details of a Company
         * @summary Update Company
         * @param {string} companyId
         * @param {Company} company
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdPut: (companyId, company, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdPut', 'companyId', companyId);
            // verify required parameter 'company' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdPut', 'company', company);
            const localVarPath = `/company/{company_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(company, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a Company on behalf of a customer account to include all managed network entities  i.e. Trusted Parties, Holdings, Funds, Custody Policies and those for the movement of assets (deposits, transfers, and withdrawals).
         * @summary Create Company
         * @param {Company} company
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyPost: (company, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'company' is not null or undefined
            (0, common_1.assertParamExists)('companyPost', 'company', company);
            const localVarPath = `/company`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(company, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search for a Company in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all companies where those letters exist.
         * @summary Search Company
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {string} [query]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companySearchGet: (xNonce, xTimestamp, xSign, query, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/company/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CompanyApiAxiosParamCreator = CompanyApiAxiosParamCreator;
/**
 * CompanyApi - functional programming interface
 * @export
 */
const CompanyApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CompanyApiAxiosParamCreator)(configuration);
    return {
        /**
         * returns details of a Company from the Company ID.
         * @summary Get Company
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdGet(companyId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdGet(companyId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Change details of a Company
         * @summary Update Company
         * @param {string} companyId
         * @param {Company} company
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdPut(companyId, company, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdPut(companyId, company, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Create a Company on behalf of a customer account to include all managed network entities  i.e. Trusted Parties, Holdings, Funds, Custody Policies and those for the movement of assets (deposits, transfers, and withdrawals).
         * @summary Create Company
         * @param {Company} company
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyPost(company, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyPost(company, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Search for a Company in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all companies where those letters exist.
         * @summary Search Company
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {string} [query]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companySearchGet(xNonce, xTimestamp, xSign, query, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companySearchGet(xNonce, xTimestamp, xSign, query, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CompanyApiFp = CompanyApiFp;
/**
 * CompanyApi - factory interface
 * @export
 */
const CompanyApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CompanyApiFp)(configuration);
    return {
        /**
         * returns details of a Company from the Company ID.
         * @summary Get Company
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdGet(companyId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Change details of a Company
         * @summary Update Company
         * @param {string} companyId
         * @param {Company} company
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdPut(companyId, company, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdPut(companyId, company, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Company on behalf of a customer account to include all managed network entities  i.e. Trusted Parties, Holdings, Funds, Custody Policies and those for the movement of assets (deposits, transfers, and withdrawals).
         * @summary Create Company
         * @param {Company} company
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyPost(company, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyPost(company, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for a Company in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all companies where those letters exist.
         * @summary Search Company
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {string} [query]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companySearchGet(xNonce, xTimestamp, xSign, query, options) {
            return localVarFp.companySearchGet(xNonce, xTimestamp, xSign, query, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CompanyApiFactory = CompanyApiFactory;
/**
 * CompanyApi - object-oriented interface
 * @export
 * @class CompanyApi
 * @extends {BaseAPI}
 */
class CompanyApi extends base_1.BaseAPI {
    /**
     * returns details of a Company from the Company ID.
     * @summary Get Company
     * @param {string} companyId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    companyCompanyIdGet(companyId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.CompanyApiFp)(this.configuration).companyCompanyIdGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Change details of a Company
     * @summary Update Company
     * @param {string} companyId
     * @param {Company} company
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    companyCompanyIdPut(companyId, company, xNonce, xTimestamp, xSign, options) {
        return (0, exports.CompanyApiFp)(this.configuration).companyCompanyIdPut(companyId, company, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a Company on behalf of a customer account to include all managed network entities  i.e. Trusted Parties, Holdings, Funds, Custody Policies and those for the movement of assets (deposits, transfers, and withdrawals).
     * @summary Create Company
     * @param {Company} company
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    companyPost(company, xNonce, xTimestamp, xSign, options) {
        return (0, exports.CompanyApiFp)(this.configuration).companyPost(company, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search for a Company in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all companies where those letters exist.
     * @summary Search Company
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {string} [query]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    companySearchGet(xNonce, xTimestamp, xSign, query, options) {
        return (0, exports.CompanyApiFp)(this.configuration).companySearchGet(xNonce, xTimestamp, xSign, query, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CompanyApi = CompanyApi;
/**
 * CoreClientApi - axios parameter creator
 * @export
 */
const CoreClientApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Reject a specific action
         * @param {string} clientId
         * @param {string} actionId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdDelete: (clientId, actionId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'clientId' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdActionActionIdDelete', 'clientId', clientId);
            // verify required parameter 'actionId' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdActionActionIdDelete', 'actionId', actionId);
            const localVarPath = `/coreclient/{client_id}/action/{action_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)))
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the details of an action including Type, Status, Timestamp and Expiry Time.
         * @summary Details of an action
         * @param {string} clientId
         * @param {string} actionId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdGet: (clientId, actionId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'clientId' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdActionActionIdGet', 'clientId', clientId);
            // verify required parameter 'actionId' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdActionActionIdGet', 'actionId', actionId);
            const localVarPath = `/coreclient/{client_id}/action/{action_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)))
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Approve a specific action
         * @summary Approve action
         * @param {string} clientId
         * @param {string} actionId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdPut: (clientId, actionId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'clientId' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdActionActionIdPut', 'clientId', clientId);
            // verify required parameter 'actionId' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdActionActionIdPut', 'actionId', actionId);
            const localVarPath = `/coreclient/{client_id}/action/{action_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)))
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns actions with a status of \'Pending\'
         * @summary Pending actions
         * @param {string} clientId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionsGet: (clientId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'clientId' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdActionsGet', 'clientId', clientId);
            const localVarPath = `/coreclient/{client_id}/actions`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Obtain details on connected wallets and wallets pending approval
         * @summary Get connected wallets
         * @param {string} clientId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdWalletsGet: (clientId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'clientId' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdWalletsGet', 'clientId', clientId);
            const localVarPath = `/coreclient/{client_id}/wallets`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a list of all registered Core Clients
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientGet: (xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/coreclient`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create a new Core Client
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {NewCoreClient} [newCoreClient]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientPost: (xNonce, xTimestamp, xSign, newCoreClient, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/coreclient`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(newCoreClient, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CoreClientApiAxiosParamCreator = CoreClientApiAxiosParamCreator;
/**
 * CoreClientApi - functional programming interface
 * @export
 */
const CoreClientApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CoreClientApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Reject a specific action
         * @param {string} clientId
         * @param {string} actionId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdDelete(clientId, actionId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientClientIdActionActionIdDelete(clientId, actionId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns the details of an action including Type, Status, Timestamp and Expiry Time.
         * @summary Details of an action
         * @param {string} clientId
         * @param {string} actionId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdGet(clientId, actionId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientClientIdActionActionIdGet(clientId, actionId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Approve a specific action
         * @summary Approve action
         * @param {string} clientId
         * @param {string} actionId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdPut(clientId, actionId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientClientIdActionActionIdPut(clientId, actionId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns actions with a status of \'Pending\'
         * @summary Pending actions
         * @param {string} clientId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionsGet(clientId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientClientIdActionsGet(clientId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Obtain details on connected wallets and wallets pending approval
         * @summary Get connected wallets
         * @param {string} clientId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdWalletsGet(clientId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientClientIdWalletsGet(clientId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get a list of all registered Core Clients
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientGet(xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientGet(xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create a new Core Client
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {NewCoreClient} [newCoreClient]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientPost(xNonce, xTimestamp, xSign, newCoreClient, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientPost(xNonce, xTimestamp, xSign, newCoreClient, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CoreClientApiFp = CoreClientApiFp;
/**
 * CoreClientApi - factory interface
 * @export
 */
const CoreClientApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CoreClientApiFp)(configuration);
    return {
        /**
         *
         * @summary Reject a specific action
         * @param {string} clientId
         * @param {string} actionId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdDelete(clientId, actionId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.coreclientClientIdActionActionIdDelete(clientId, actionId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of an action including Type, Status, Timestamp and Expiry Time.
         * @summary Details of an action
         * @param {string} clientId
         * @param {string} actionId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdGet(clientId, actionId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.coreclientClientIdActionActionIdGet(clientId, actionId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve a specific action
         * @summary Approve action
         * @param {string} clientId
         * @param {string} actionId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdPut(clientId, actionId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.coreclientClientIdActionActionIdPut(clientId, actionId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns actions with a status of \'Pending\'
         * @summary Pending actions
         * @param {string} clientId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionsGet(clientId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.coreclientClientIdActionsGet(clientId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain details on connected wallets and wallets pending approval
         * @summary Get connected wallets
         * @param {string} clientId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdWalletsGet(clientId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.coreclientClientIdWalletsGet(clientId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a list of all registered Core Clients
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientGet(xNonce, xTimestamp, xSign, options) {
            return localVarFp.coreclientGet(xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new Core Client
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {NewCoreClient} [newCoreClient]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientPost(xNonce, xTimestamp, xSign, newCoreClient, options) {
            return localVarFp.coreclientPost(xNonce, xTimestamp, xSign, newCoreClient, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CoreClientApiFactory = CoreClientApiFactory;
/**
 * CoreClientApi - object-oriented interface
 * @export
 * @class CoreClientApi
 * @extends {BaseAPI}
 */
class CoreClientApi extends base_1.BaseAPI {
    /**
     *
     * @summary Reject a specific action
     * @param {string} clientId
     * @param {string} actionId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    coreclientClientIdActionActionIdDelete(clientId, actionId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.CoreClientApiFp)(this.configuration).coreclientClientIdActionActionIdDelete(clientId, actionId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the details of an action including Type, Status, Timestamp and Expiry Time.
     * @summary Details of an action
     * @param {string} clientId
     * @param {string} actionId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    coreclientClientIdActionActionIdGet(clientId, actionId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.CoreClientApiFp)(this.configuration).coreclientClientIdActionActionIdGet(clientId, actionId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Approve a specific action
     * @summary Approve action
     * @param {string} clientId
     * @param {string} actionId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    coreclientClientIdActionActionIdPut(clientId, actionId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.CoreClientApiFp)(this.configuration).coreclientClientIdActionActionIdPut(clientId, actionId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns actions with a status of \'Pending\'
     * @summary Pending actions
     * @param {string} clientId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    coreclientClientIdActionsGet(clientId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.CoreClientApiFp)(this.configuration).coreclientClientIdActionsGet(clientId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Obtain details on connected wallets and wallets pending approval
     * @summary Get connected wallets
     * @param {string} clientId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    coreclientClientIdWalletsGet(clientId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.CoreClientApiFp)(this.configuration).coreclientClientIdWalletsGet(clientId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a list of all registered Core Clients
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    coreclientGet(xNonce, xTimestamp, xSign, options) {
        return (0, exports.CoreClientApiFp)(this.configuration).coreclientGet(xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new Core Client
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {NewCoreClient} [newCoreClient]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    coreclientPost(xNonce, xTimestamp, xSign, newCoreClient, options) {
        return (0, exports.CoreClientApiFp)(this.configuration).coreclientPost(xNonce, xTimestamp, xSign, newCoreClient, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CoreClientApi = CoreClientApi;
/**
 * CoreClientSignApi - axios parameter creator
 * @export
 */
const CoreClientSignApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Signs a hash message with the core client\'s BLS key. The message should be no bigger than 64 bytes, hex encoded
         * @summary Sign a hash
         * @param {string} clientId
         * @param {CoreClientSign} coreClientSign
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSignPost: (clientId, coreClientSign, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'clientId' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdSignPost', 'clientId', clientId);
            // verify required parameter 'coreClientSign' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdSignPost', 'coreClientSign', coreClientSign);
            const localVarPath = `/coreclient/{client_id}/sign`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(coreClientSign, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Verifies a signature
         * @summary Verify signature
         * @param {CoreClientVerifySignature} coreClientVerifySignature
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientVerifyPost: (coreClientVerifySignature, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'coreClientVerifySignature' is not null or undefined
            (0, common_1.assertParamExists)('coreclientVerifyPost', 'coreClientVerifySignature', coreClientVerifySignature);
            const localVarPath = `/coreclient/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(coreClientVerifySignature, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CoreClientSignApiAxiosParamCreator = CoreClientSignApiAxiosParamCreator;
/**
 * CoreClientSignApi - functional programming interface
 * @export
 */
const CoreClientSignApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CoreClientSignApiAxiosParamCreator)(configuration);
    return {
        /**
         * Signs a hash message with the core client\'s BLS key. The message should be no bigger than 64 bytes, hex encoded
         * @summary Sign a hash
         * @param {string} clientId
         * @param {CoreClientSign} coreClientSign
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSignPost(clientId, coreClientSign, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientClientIdSignPost(clientId, coreClientSign, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Verifies a signature
         * @summary Verify signature
         * @param {CoreClientVerifySignature} coreClientVerifySignature
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientVerifyPost(coreClientVerifySignature, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientVerifyPost(coreClientVerifySignature, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CoreClientSignApiFp = CoreClientSignApiFp;
/**
 * CoreClientSignApi - factory interface
 * @export
 */
const CoreClientSignApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CoreClientSignApiFp)(configuration);
    return {
        /**
         * Signs a hash message with the core client\'s BLS key. The message should be no bigger than 64 bytes, hex encoded
         * @summary Sign a hash
         * @param {string} clientId
         * @param {CoreClientSign} coreClientSign
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSignPost(clientId, coreClientSign, xNonce, xTimestamp, xSign, options) {
            return localVarFp.coreclientClientIdSignPost(clientId, coreClientSign, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies a signature
         * @summary Verify signature
         * @param {CoreClientVerifySignature} coreClientVerifySignature
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientVerifyPost(coreClientVerifySignature, xNonce, xTimestamp, xSign, options) {
            return localVarFp.coreclientVerifyPost(coreClientVerifySignature, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CoreClientSignApiFactory = CoreClientSignApiFactory;
/**
 * CoreClientSignApi - object-oriented interface
 * @export
 * @class CoreClientSignApi
 * @extends {BaseAPI}
 */
class CoreClientSignApi extends base_1.BaseAPI {
    /**
     * Signs a hash message with the core client\'s BLS key. The message should be no bigger than 64 bytes, hex encoded
     * @summary Sign a hash
     * @param {string} clientId
     * @param {CoreClientSign} coreClientSign
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientSignApi
     */
    coreclientClientIdSignPost(clientId, coreClientSign, xNonce, xTimestamp, xSign, options) {
        return (0, exports.CoreClientSignApiFp)(this.configuration).coreclientClientIdSignPost(clientId, coreClientSign, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Verifies a signature
     * @summary Verify signature
     * @param {CoreClientVerifySignature} coreClientVerifySignature
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientSignApi
     */
    coreclientVerifyPost(coreClientVerifySignature, xNonce, xTimestamp, xSign, options) {
        return (0, exports.CoreClientSignApiFp)(this.configuration).coreclientVerifyPost(coreClientVerifySignature, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CoreClientSignApi = CoreClientSignApi;
/**
 * FundApi - axios parameter creator
 * @export
 */
const FundApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add an Asset to an existing fund
         * @summary Add Asset to a fund
         * @param {string} companyId
         * @param {string} fundId
         * @param {FundAsset} fundAsset
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdAssetPost: (companyId, fundId, fundAsset, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdAssetPost', 'companyId', companyId);
            // verify required parameter 'fundId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdAssetPost', 'fundId', fundId);
            // verify required parameter 'fundAsset' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdAssetPost', 'fundAsset', fundAsset);
            const localVarPath = `/company/{company_id}/fund/{fund_id}/asset`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(fundAsset, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * returns a list of fund assets with their Deposit Addresses and current balances. Each fund contains one or more deposit addresses for the different types of assets.
         * @summary Get Fund Deposit Address
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdDepositGet: (companyId, fundId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdDepositGet', 'companyId', companyId);
            // verify required parameter 'fundId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdDepositGet', 'fundId', fundId);
            const localVarPath = `/company/{company_id}/fund/{fund_id}/deposit`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * returns basic information on the Fund including the custody groups for withdrawal and transfers. There are also details on fund members who are part of each custody group.
         * @summary Get Fund
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdGet: (companyId, fundId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdGet', 'companyId', companyId);
            // verify required parameter 'fundId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdGet', 'fundId', fundId);
            const localVarPath = `/company/{company_id}/fund/{fund_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get transaction ledger for a fund
         * @summary Transaction ledger
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {string} [asset]
         * @param {string} [walletId]
         * @param {'all' | 'in' | 'out'} [direction]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdLedgerGet: (companyId, fundId, xNonce, xTimestamp, xSign, asset, walletId, direction, offset, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdLedgerGet', 'companyId', companyId);
            // verify required parameter 'fundId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdLedgerGet', 'fundId', fundId);
            const localVarPath = `/company/{company_id}/fund/{fund_id}/ledger`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }
            if (walletId !== undefined) {
                localVarQueryParameter['wallet_id'] = walletId;
            }
            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
         * @summary Add Wallet to a fund
         * @param {string} companyId
         * @param {string} fundId
         * @param {FundWallet} fundWallet
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWalletPost: (companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdWalletPost', 'companyId', companyId);
            // verify required parameter 'fundId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdWalletPost', 'fundId', fundId);
            // verify required parameter 'fundWallet' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdWalletPost', 'fundWallet', fundWallet);
            const localVarPath = `/company/{company_id}/fund/{fund_id}/wallet`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(fundWallet, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Whitelisted addresses for fund transactions.
         * @summary Get Fund Whitelist
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {string} [address]
         * @param {string} [asset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWhitelistGet: (companyId, fundId, xNonce, xTimestamp, xSign, address, asset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdWhitelistGet', 'companyId', companyId);
            // verify required parameter 'fundId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdWhitelistGet', 'fundId', fundId);
            const localVarPath = `/company/{company_id}/fund/{fund_id}/whitelist`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * An address needs to be Whitelisted to ensure it is approved for a withdrawal transaction.
         * @summary Add Whitelist address
         * @param {string} companyId
         * @param {string} fundId
         * @param {AddFundWhitelist} addFundWhitelist
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWhitelistPost: (companyId, fundId, addFundWhitelist, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdWhitelistPost', 'companyId', companyId);
            // verify required parameter 'fundId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdWhitelistPost', 'fundId', fundId);
            // verify required parameter 'addFundWhitelist' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdWhitelistPost', 'addFundWhitelist', addFundWhitelist);
            const localVarPath = `/company/{company_id}/fund/{fund_id}/whitelist`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addFundWhitelist, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a Fund that serves as a wallet containing assets, addresses, and custody policies. Custody policies for both deposits and withdrawals must exist for a fund. Policies can include multiple custodians, or a single user that self-manages custody. For an individual fund, you can also add whitelisted withdrawal addresses.
         * @summary Add Fund
         * @param {string} companyId
         * @param {Fund} fund
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundPost: (companyId, fund, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundPost', 'companyId', companyId);
            // verify required parameter 'fund' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundPost', 'fund', fund);
            const localVarPath = `/company/{company_id}/fund`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(fund, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search funds in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all funds where those letters exist.
         * @summary Search Fund
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {string} [query]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundSearchGet: (companyId, xNonce, xTimestamp, xSign, query, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundSearchGet', 'companyId', companyId);
            const localVarPath = `/company/{company_id}/fund/search`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FundApiAxiosParamCreator = FundApiAxiosParamCreator;
/**
 * FundApi - functional programming interface
 * @export
 */
const FundApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FundApiAxiosParamCreator)(configuration);
    return {
        /**
         * Add an Asset to an existing fund
         * @summary Add Asset to a fund
         * @param {string} companyId
         * @param {string} fundId
         * @param {FundAsset} fundAsset
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdAssetPost(companyId, fundId, fundAsset, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdFundFundIdAssetPost(companyId, fundId, fundAsset, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * returns a list of fund assets with their Deposit Addresses and current balances. Each fund contains one or more deposit addresses for the different types of assets.
         * @summary Get Fund Deposit Address
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdDepositGet(companyId, fundId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdFundFundIdDepositGet(companyId, fundId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * returns basic information on the Fund including the custody groups for withdrawal and transfers. There are also details on fund members who are part of each custody group.
         * @summary Get Fund
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdGet(companyId, fundId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdFundFundIdGet(companyId, fundId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get transaction ledger for a fund
         * @summary Transaction ledger
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {string} [asset]
         * @param {string} [walletId]
         * @param {'all' | 'in' | 'out'} [direction]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdLedgerGet(companyId, fundId, xNonce, xTimestamp, xSign, asset, walletId, direction, offset, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdFundFundIdLedgerGet(companyId, fundId, xNonce, xTimestamp, xSign, asset, walletId, direction, offset, limit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
         * @summary Add Wallet to a fund
         * @param {string} companyId
         * @param {string} fundId
         * @param {FundWallet} fundWallet
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get Whitelisted addresses for fund transactions.
         * @summary Get Fund Whitelist
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {string} [address]
         * @param {string} [asset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWhitelistGet(companyId, fundId, xNonce, xTimestamp, xSign, address, asset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdFundFundIdWhitelistGet(companyId, fundId, xNonce, xTimestamp, xSign, address, asset, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * An address needs to be Whitelisted to ensure it is approved for a withdrawal transaction.
         * @summary Add Whitelist address
         * @param {string} companyId
         * @param {string} fundId
         * @param {AddFundWhitelist} addFundWhitelist
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWhitelistPost(companyId, fundId, addFundWhitelist, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdFundFundIdWhitelistPost(companyId, fundId, addFundWhitelist, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Create a Fund that serves as a wallet containing assets, addresses, and custody policies. Custody policies for both deposits and withdrawals must exist for a fund. Policies can include multiple custodians, or a single user that self-manages custody. For an individual fund, you can also add whitelisted withdrawal addresses.
         * @summary Add Fund
         * @param {string} companyId
         * @param {Fund} fund
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundPost(companyId, fund, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdFundPost(companyId, fund, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Search funds in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all funds where those letters exist.
         * @summary Search Fund
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {string} [query]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundSearchGet(companyId, xNonce, xTimestamp, xSign, query, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdFundSearchGet(companyId, xNonce, xTimestamp, xSign, query, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.FundApiFp = FundApiFp;
/**
 * FundApi - factory interface
 * @export
 */
const FundApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FundApiFp)(configuration);
    return {
        /**
         * Add an Asset to an existing fund
         * @summary Add Asset to a fund
         * @param {string} companyId
         * @param {string} fundId
         * @param {FundAsset} fundAsset
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdAssetPost(companyId, fundId, fundAsset, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdFundFundIdAssetPost(companyId, fundId, fundAsset, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * returns a list of fund assets with their Deposit Addresses and current balances. Each fund contains one or more deposit addresses for the different types of assets.
         * @summary Get Fund Deposit Address
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdDepositGet(companyId, fundId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdFundFundIdDepositGet(companyId, fundId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * returns basic information on the Fund including the custody groups for withdrawal and transfers. There are also details on fund members who are part of each custody group.
         * @summary Get Fund
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdGet(companyId, fundId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdFundFundIdGet(companyId, fundId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Get transaction ledger for a fund
         * @summary Transaction ledger
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {string} [asset]
         * @param {string} [walletId]
         * @param {'all' | 'in' | 'out'} [direction]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdLedgerGet(companyId, fundId, xNonce, xTimestamp, xSign, asset, walletId, direction, offset, limit, options) {
            return localVarFp.companyCompanyIdFundFundIdLedgerGet(companyId, fundId, xNonce, xTimestamp, xSign, asset, walletId, direction, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
         * @summary Add Wallet to a fund
         * @param {string} companyId
         * @param {string} fundId
         * @param {FundWallet} fundWallet
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Whitelisted addresses for fund transactions.
         * @summary Get Fund Whitelist
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {string} [address]
         * @param {string} [asset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWhitelistGet(companyId, fundId, xNonce, xTimestamp, xSign, address, asset, options) {
            return localVarFp.companyCompanyIdFundFundIdWhitelistGet(companyId, fundId, xNonce, xTimestamp, xSign, address, asset, options).then((request) => request(axios, basePath));
        },
        /**
         * An address needs to be Whitelisted to ensure it is approved for a withdrawal transaction.
         * @summary Add Whitelist address
         * @param {string} companyId
         * @param {string} fundId
         * @param {AddFundWhitelist} addFundWhitelist
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWhitelistPost(companyId, fundId, addFundWhitelist, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdFundFundIdWhitelistPost(companyId, fundId, addFundWhitelist, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Fund that serves as a wallet containing assets, addresses, and custody policies. Custody policies for both deposits and withdrawals must exist for a fund. Policies can include multiple custodians, or a single user that self-manages custody. For an individual fund, you can also add whitelisted withdrawal addresses.
         * @summary Add Fund
         * @param {string} companyId
         * @param {Fund} fund
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundPost(companyId, fund, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdFundPost(companyId, fund, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Search funds in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all funds where those letters exist.
         * @summary Search Fund
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {string} [query]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundSearchGet(companyId, xNonce, xTimestamp, xSign, query, options) {
            return localVarFp.companyCompanyIdFundSearchGet(companyId, xNonce, xTimestamp, xSign, query, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FundApiFactory = FundApiFactory;
/**
 * FundApi - object-oriented interface
 * @export
 * @class FundApi
 * @extends {BaseAPI}
 */
class FundApi extends base_1.BaseAPI {
    /**
     * Add an Asset to an existing fund
     * @summary Add Asset to a fund
     * @param {string} companyId
     * @param {string} fundId
     * @param {FundAsset} fundAsset
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    companyCompanyIdFundFundIdAssetPost(companyId, fundId, fundAsset, xNonce, xTimestamp, xSign, options) {
        return (0, exports.FundApiFp)(this.configuration).companyCompanyIdFundFundIdAssetPost(companyId, fundId, fundAsset, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * returns a list of fund assets with their Deposit Addresses and current balances. Each fund contains one or more deposit addresses for the different types of assets.
     * @summary Get Fund Deposit Address
     * @param {string} companyId
     * @param {string} fundId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    companyCompanyIdFundFundIdDepositGet(companyId, fundId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.FundApiFp)(this.configuration).companyCompanyIdFundFundIdDepositGet(companyId, fundId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * returns basic information on the Fund including the custody groups for withdrawal and transfers. There are also details on fund members who are part of each custody group.
     * @summary Get Fund
     * @param {string} companyId
     * @param {string} fundId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    companyCompanyIdFundFundIdGet(companyId, fundId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.FundApiFp)(this.configuration).companyCompanyIdFundFundIdGet(companyId, fundId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get transaction ledger for a fund
     * @summary Transaction ledger
     * @param {string} companyId
     * @param {string} fundId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {string} [asset]
     * @param {string} [walletId]
     * @param {'all' | 'in' | 'out'} [direction]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    companyCompanyIdFundFundIdLedgerGet(companyId, fundId, xNonce, xTimestamp, xSign, asset, walletId, direction, offset, limit, options) {
        return (0, exports.FundApiFp)(this.configuration).companyCompanyIdFundFundIdLedgerGet(companyId, fundId, xNonce, xTimestamp, xSign, asset, walletId, direction, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
     * @summary Add Wallet to a fund
     * @param {string} companyId
     * @param {string} fundId
     * @param {FundWallet} fundWallet
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options) {
        return (0, exports.FundApiFp)(this.configuration).companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Whitelisted addresses for fund transactions.
     * @summary Get Fund Whitelist
     * @param {string} companyId
     * @param {string} fundId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {string} [address]
     * @param {string} [asset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    companyCompanyIdFundFundIdWhitelistGet(companyId, fundId, xNonce, xTimestamp, xSign, address, asset, options) {
        return (0, exports.FundApiFp)(this.configuration).companyCompanyIdFundFundIdWhitelistGet(companyId, fundId, xNonce, xTimestamp, xSign, address, asset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * An address needs to be Whitelisted to ensure it is approved for a withdrawal transaction.
     * @summary Add Whitelist address
     * @param {string} companyId
     * @param {string} fundId
     * @param {AddFundWhitelist} addFundWhitelist
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    companyCompanyIdFundFundIdWhitelistPost(companyId, fundId, addFundWhitelist, xNonce, xTimestamp, xSign, options) {
        return (0, exports.FundApiFp)(this.configuration).companyCompanyIdFundFundIdWhitelistPost(companyId, fundId, addFundWhitelist, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a Fund that serves as a wallet containing assets, addresses, and custody policies. Custody policies for both deposits and withdrawals must exist for a fund. Policies can include multiple custodians, or a single user that self-manages custody. For an individual fund, you can also add whitelisted withdrawal addresses.
     * @summary Add Fund
     * @param {string} companyId
     * @param {Fund} fund
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    companyCompanyIdFundPost(companyId, fund, xNonce, xTimestamp, xSign, options) {
        return (0, exports.FundApiFp)(this.configuration).companyCompanyIdFundPost(companyId, fund, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search funds in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all funds where those letters exist.
     * @summary Search Fund
     * @param {string} companyId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {string} [query]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    companyCompanyIdFundSearchGet(companyId, xNonce, xTimestamp, xSign, query, options) {
        return (0, exports.FundApiFp)(this.configuration).companyCompanyIdFundSearchGet(companyId, xNonce, xTimestamp, xSign, query, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FundApi = FundApi;
/**
 * HoldingApi - axios parameter creator
 * @export
 */
const HoldingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * returns information on all the assets for a company on the Qredo network. Each Holding is divided according to the asset type. Each Holding entry also includes the balance for that asset, allowing you to track funds coming in and out.
         * @summary Get Holdings
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdHoldingGet: (companyId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdHoldingGet', 'companyId', companyId);
            const localVarPath = `/company/{company_id}/holding`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.HoldingApiAxiosParamCreator = HoldingApiAxiosParamCreator;
/**
 * HoldingApi - functional programming interface
 * @export
 */
const HoldingApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.HoldingApiAxiosParamCreator)(configuration);
    return {
        /**
         * returns information on all the assets for a company on the Qredo network. Each Holding is divided according to the asset type. Each Holding entry also includes the balance for that asset, allowing you to track funds coming in and out.
         * @summary Get Holdings
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdHoldingGet(companyId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdHoldingGet(companyId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.HoldingApiFp = HoldingApiFp;
/**
 * HoldingApi - factory interface
 * @export
 */
const HoldingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.HoldingApiFp)(configuration);
    return {
        /**
         * returns information on all the assets for a company on the Qredo network. Each Holding is divided according to the asset type. Each Holding entry also includes the balance for that asset, allowing you to track funds coming in and out.
         * @summary Get Holdings
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdHoldingGet(companyId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdHoldingGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};
exports.HoldingApiFactory = HoldingApiFactory;
/**
 * HoldingApi - object-oriented interface
 * @export
 * @class HoldingApi
 * @extends {BaseAPI}
 */
class HoldingApi extends base_1.BaseAPI {
    /**
     * returns information on all the assets for a company on the Qredo network. Each Holding is divided according to the asset type. Each Holding entry also includes the balance for that asset, allowing you to track funds coming in and out.
     * @summary Get Holdings
     * @param {string} companyId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HoldingApi
     */
    companyCompanyIdHoldingGet(companyId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.HoldingApiFp)(this.configuration).companyCompanyIdHoldingGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.HoldingApi = HoldingApi;
/**
 * LiquidityHubApi - axios parameter creator
 * @export
 */
const LiquidityHubApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
         * @summary Get Liquidity Hub
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdLiquidityhubGet: (companyId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdLiquidityhubGet', 'companyId', companyId);
            const localVarPath = `/company/{company_id}/liquidityhub`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add an existing swap to the liquidity hub.
         * @summary Add to liquidity hub
         * @param {string} companyId
         * @param {AddToLiquidityHub} addToLiquidityHub
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdLiquidityhubPost: (companyId, addToLiquidityHub, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdLiquidityhubPost', 'companyId', companyId);
            // verify required parameter 'addToLiquidityHub' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdLiquidityhubPost', 'addToLiquidityHub', addToLiquidityHub);
            const localVarPath = `/company/{company_id}/liquidityhub`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addToLiquidityHub, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
         * @summary Get Liquidity Hub
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityhubGet: (xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/liquidityhub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.LiquidityHubApiAxiosParamCreator = LiquidityHubApiAxiosParamCreator;
/**
 * LiquidityHubApi - functional programming interface
 * @export
 */
const LiquidityHubApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.LiquidityHubApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
         * @summary Get Liquidity Hub
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdLiquidityhubGet(companyId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdLiquidityhubGet(companyId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Add an existing swap to the liquidity hub.
         * @summary Add to liquidity hub
         * @param {string} companyId
         * @param {AddToLiquidityHub} addToLiquidityHub
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdLiquidityhubPost(companyId, addToLiquidityHub, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdLiquidityhubPost(companyId, addToLiquidityHub, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
         * @summary Get Liquidity Hub
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityhubGet(xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.liquidityhubGet(xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.LiquidityHubApiFp = LiquidityHubApiFp;
/**
 * LiquidityHubApi - factory interface
 * @export
 */
const LiquidityHubApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.LiquidityHubApiFp)(configuration);
    return {
        /**
         * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
         * @summary Get Liquidity Hub
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdLiquidityhubGet(companyId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdLiquidityhubGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an existing swap to the liquidity hub.
         * @summary Add to liquidity hub
         * @param {string} companyId
         * @param {AddToLiquidityHub} addToLiquidityHub
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdLiquidityhubPost(companyId, addToLiquidityHub, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdLiquidityhubPost(companyId, addToLiquidityHub, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
         * @summary Get Liquidity Hub
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityhubGet(xNonce, xTimestamp, xSign, options) {
            return localVarFp.liquidityhubGet(xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};
exports.LiquidityHubApiFactory = LiquidityHubApiFactory;
/**
 * LiquidityHubApi - object-oriented interface
 * @export
 * @class LiquidityHubApi
 * @extends {BaseAPI}
 */
class LiquidityHubApi extends base_1.BaseAPI {
    /**
     * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
     * @summary Get Liquidity Hub
     * @param {string} companyId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityHubApi
     */
    companyCompanyIdLiquidityhubGet(companyId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.LiquidityHubApiFp)(this.configuration).companyCompanyIdLiquidityhubGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add an existing swap to the liquidity hub.
     * @summary Add to liquidity hub
     * @param {string} companyId
     * @param {AddToLiquidityHub} addToLiquidityHub
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityHubApi
     */
    companyCompanyIdLiquidityhubPost(companyId, addToLiquidityHub, xNonce, xTimestamp, xSign, options) {
        return (0, exports.LiquidityHubApiFp)(this.configuration).companyCompanyIdLiquidityhubPost(companyId, addToLiquidityHub, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
     * @summary Get Liquidity Hub
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityHubApi
     */
    liquidityhubGet(xNonce, xTimestamp, xSign, options) {
        return (0, exports.LiquidityHubApiFp)(this.configuration).liquidityhubGet(xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.LiquidityHubApi = LiquidityHubApi;
/**
 * SweepApi - axios parameter creator
 * @export
 */
const SweepApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Initiate a new sweep transactions and set parameters for the transaction.
         * @summary New sweep
         * @param {string} clientId
         * @param {Sweep} sweep
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSweepPost: (clientId, sweep, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'clientId' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdSweepPost', 'clientId', clientId);
            // verify required parameter 'sweep' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdSweepPost', 'sweep', sweep);
            const localVarPath = `/coreclient/{client_id}/sweep`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(sweep, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Obtain details on a sweep transaction status
         * @summary Get sweep status
         * @param {string} clientId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSweepTxIdGet: (clientId, txId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'clientId' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdSweepTxIdGet', 'clientId', clientId);
            // verify required parameter 'txId' is not null or undefined
            (0, common_1.assertParamExists)('coreclientClientIdSweepTxIdGet', 'txId', txId);
            const localVarPath = `/coreclient/{client_id}/sweep/{tx_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)))
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SweepApiAxiosParamCreator = SweepApiAxiosParamCreator;
/**
 * SweepApi - functional programming interface
 * @export
 */
const SweepApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SweepApiAxiosParamCreator)(configuration);
    return {
        /**
         * Initiate a new sweep transactions and set parameters for the transaction.
         * @summary New sweep
         * @param {string} clientId
         * @param {Sweep} sweep
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSweepPost(clientId, sweep, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientClientIdSweepPost(clientId, sweep, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Obtain details on a sweep transaction status
         * @summary Get sweep status
         * @param {string} clientId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSweepTxIdGet(clientId, txId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.coreclientClientIdSweepTxIdGet(clientId, txId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.SweepApiFp = SweepApiFp;
/**
 * SweepApi - factory interface
 * @export
 */
const SweepApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SweepApiFp)(configuration);
    return {
        /**
         * Initiate a new sweep transactions and set parameters for the transaction.
         * @summary New sweep
         * @param {string} clientId
         * @param {Sweep} sweep
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSweepPost(clientId, sweep, xNonce, xTimestamp, xSign, options) {
            return localVarFp.coreclientClientIdSweepPost(clientId, sweep, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain details on a sweep transaction status
         * @summary Get sweep status
         * @param {string} clientId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSweepTxIdGet(clientId, txId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.coreclientClientIdSweepTxIdGet(clientId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SweepApiFactory = SweepApiFactory;
/**
 * SweepApi - object-oriented interface
 * @export
 * @class SweepApi
 * @extends {BaseAPI}
 */
class SweepApi extends base_1.BaseAPI {
    /**
     * Initiate a new sweep transactions and set parameters for the transaction.
     * @summary New sweep
     * @param {string} clientId
     * @param {Sweep} sweep
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SweepApi
     */
    coreclientClientIdSweepPost(clientId, sweep, xNonce, xTimestamp, xSign, options) {
        return (0, exports.SweepApiFp)(this.configuration).coreclientClientIdSweepPost(clientId, sweep, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Obtain details on a sweep transaction status
     * @summary Get sweep status
     * @param {string} clientId
     * @param {string} txId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SweepApi
     */
    coreclientClientIdSweepTxIdGet(clientId, txId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.SweepApiFp)(this.configuration).coreclientClientIdSweepTxIdGet(clientId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SweepApi = SweepApi;
/**
 * TransferApi - axios parameter creator
 * @export
 */
const TransferApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Initiate a new Transfer on a fund that includes various settings for the transaction. When a transfer transaction is created, custodian(s) need to approve it via their Qredo Signing app. The number of custodian approvals depends on the Transfer Policy settings for the fund.
         * @summary New Transfer
         * @param {string} companyId
         * @param {Transfer} transfer
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTransferPost: (companyId, transfer, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdTransferPost', 'companyId', companyId);
            // verify required parameter 'transfer' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdTransferPost', 'transfer', transfer);
            const localVarPath = `/company/{company_id}/transfer`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transfer, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * returns the Transfer Status for a specific transaction at that point in time.
         * @summary Get Transfer Status
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTransferTxIdGet: (companyId, txId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdTransferTxIdGet', 'companyId', companyId);
            // verify required parameter 'txId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdTransferTxIdGet', 'txId', txId);
            const localVarPath = `/company/{company_id}/transfer/{tx_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TransferApiAxiosParamCreator = TransferApiAxiosParamCreator;
/**
 * TransferApi - functional programming interface
 * @export
 */
const TransferApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransferApiAxiosParamCreator)(configuration);
    return {
        /**
         * Initiate a new Transfer on a fund that includes various settings for the transaction. When a transfer transaction is created, custodian(s) need to approve it via their Qredo Signing app. The number of custodian approvals depends on the Transfer Policy settings for the fund.
         * @summary New Transfer
         * @param {string} companyId
         * @param {Transfer} transfer
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTransferPost(companyId, transfer, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdTransferPost(companyId, transfer, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * returns the Transfer Status for a specific transaction at that point in time.
         * @summary Get Transfer Status
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTransferTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdTransferTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TransferApiFp = TransferApiFp;
/**
 * TransferApi - factory interface
 * @export
 */
const TransferApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransferApiFp)(configuration);
    return {
        /**
         * Initiate a new Transfer on a fund that includes various settings for the transaction. When a transfer transaction is created, custodian(s) need to approve it via their Qredo Signing app. The number of custodian approvals depends on the Transfer Policy settings for the fund.
         * @summary New Transfer
         * @param {string} companyId
         * @param {Transfer} transfer
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTransferPost(companyId, transfer, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdTransferPost(companyId, transfer, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * returns the Transfer Status for a specific transaction at that point in time.
         * @summary Get Transfer Status
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTransferTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdTransferTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransferApiFactory = TransferApiFactory;
/**
 * TransferApi - object-oriented interface
 * @export
 * @class TransferApi
 * @extends {BaseAPI}
 */
class TransferApi extends base_1.BaseAPI {
    /**
     * Initiate a new Transfer on a fund that includes various settings for the transaction. When a transfer transaction is created, custodian(s) need to approve it via their Qredo Signing app. The number of custodian approvals depends on the Transfer Policy settings for the fund.
     * @summary New Transfer
     * @param {string} companyId
     * @param {Transfer} transfer
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferApi
     */
    companyCompanyIdTransferPost(companyId, transfer, xNonce, xTimestamp, xSign, options) {
        return (0, exports.TransferApiFp)(this.configuration).companyCompanyIdTransferPost(companyId, transfer, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * returns the Transfer Status for a specific transaction at that point in time.
     * @summary Get Transfer Status
     * @param {string} companyId
     * @param {string} txId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferApi
     */
    companyCompanyIdTransferTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.TransferApiFp)(this.configuration).companyCompanyIdTransferTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TransferApi = TransferApi;
/**
 * TrustedNetworkApi - axios parameter creator
 * @export
 */
const TrustedNetworkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns all Trusted Parties for a Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund.
         * @summary returns all Trusted Parties for a Company
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyGet: (companyId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdTrustedpartyGet', 'companyId', companyId);
            const localVarPath = `/company/{company_id}/trustedparty`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add a Trusted Party for the Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund. Qredo network as a Company or User.   When adding a user, they must approve this via their Qredo Signing App.
         * @summary Add Trusted Party
         * @param {string} companyId
         * @param {TrustedPartyNew} trustedPartyNew
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyPost: (companyId, trustedPartyNew, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdTrustedpartyPost', 'companyId', companyId);
            // verify required parameter 'trustedPartyNew' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdTrustedpartyPost', 'trustedPartyNew', trustedPartyNew);
            const localVarPath = `/company/{company_id}/trustedparty`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(trustedPartyNew, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Trusted Party from the trusted network.
         * @summary Del Trusted party
         * @param {string} companyId
         * @param {string} trustedpartyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyTrustedpartyIdDelete: (companyId, trustedpartyId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdTrustedpartyTrustedpartyIdDelete', 'companyId', companyId);
            // verify required parameter 'trustedpartyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdTrustedpartyTrustedpartyIdDelete', 'trustedpartyId', trustedpartyId);
            const localVarPath = `/company/{company_id}/trustedparty/{trustedparty_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"trustedparty_id"}}`, encodeURIComponent(String(trustedpartyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TrustedNetworkApiAxiosParamCreator = TrustedNetworkApiAxiosParamCreator;
/**
 * TrustedNetworkApi - functional programming interface
 * @export
 */
const TrustedNetworkApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TrustedNetworkApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns all Trusted Parties for a Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund.
         * @summary returns all Trusted Parties for a Company
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyGet(companyId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdTrustedpartyGet(companyId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Add a Trusted Party for the Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund. Qredo network as a Company or User.   When adding a user, they must approve this via their Qredo Signing App.
         * @summary Add Trusted Party
         * @param {string} companyId
         * @param {TrustedPartyNew} trustedPartyNew
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyPost(companyId, trustedPartyNew, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdTrustedpartyPost(companyId, trustedPartyNew, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete a Trusted Party from the trusted network.
         * @summary Del Trusted party
         * @param {string} companyId
         * @param {string} trustedpartyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyTrustedpartyIdDelete(companyId, trustedpartyId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdTrustedpartyTrustedpartyIdDelete(companyId, trustedpartyId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TrustedNetworkApiFp = TrustedNetworkApiFp;
/**
 * TrustedNetworkApi - factory interface
 * @export
 */
const TrustedNetworkApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TrustedNetworkApiFp)(configuration);
    return {
        /**
         * Returns all Trusted Parties for a Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund.
         * @summary returns all Trusted Parties for a Company
         * @param {string} companyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyGet(companyId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdTrustedpartyGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a Trusted Party for the Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund. Qredo network as a Company or User.   When adding a user, they must approve this via their Qredo Signing App.
         * @summary Add Trusted Party
         * @param {string} companyId
         * @param {TrustedPartyNew} trustedPartyNew
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyPost(companyId, trustedPartyNew, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdTrustedpartyPost(companyId, trustedPartyNew, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Trusted Party from the trusted network.
         * @summary Del Trusted party
         * @param {string} companyId
         * @param {string} trustedpartyId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyTrustedpartyIdDelete(companyId, trustedpartyId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdTrustedpartyTrustedpartyIdDelete(companyId, trustedpartyId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TrustedNetworkApiFactory = TrustedNetworkApiFactory;
/**
 * TrustedNetworkApi - object-oriented interface
 * @export
 * @class TrustedNetworkApi
 * @extends {BaseAPI}
 */
class TrustedNetworkApi extends base_1.BaseAPI {
    /**
     * Returns all Trusted Parties for a Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund.
     * @summary returns all Trusted Parties for a Company
     * @param {string} companyId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrustedNetworkApi
     */
    companyCompanyIdTrustedpartyGet(companyId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.TrustedNetworkApiFp)(this.configuration).companyCompanyIdTrustedpartyGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add a Trusted Party for the Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund. Qredo network as a Company or User.   When adding a user, they must approve this via their Qredo Signing App.
     * @summary Add Trusted Party
     * @param {string} companyId
     * @param {TrustedPartyNew} trustedPartyNew
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrustedNetworkApi
     */
    companyCompanyIdTrustedpartyPost(companyId, trustedPartyNew, xNonce, xTimestamp, xSign, options) {
        return (0, exports.TrustedNetworkApiFp)(this.configuration).companyCompanyIdTrustedpartyPost(companyId, trustedPartyNew, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Trusted Party from the trusted network.
     * @summary Del Trusted party
     * @param {string} companyId
     * @param {string} trustedpartyId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrustedNetworkApi
     */
    companyCompanyIdTrustedpartyTrustedpartyIdDelete(companyId, trustedpartyId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.TrustedNetworkApiFp)(this.configuration).companyCompanyIdTrustedpartyTrustedpartyIdDelete(companyId, trustedpartyId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TrustedNetworkApi = TrustedNetworkApi;
/**
 * WalletApi - axios parameter creator
 * @export
 */
const WalletApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
         * @summary Add Wallet to a fund
         * @param {string} companyId
         * @param {string} fundId
         * @param {FundWallet} fundWallet
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWalletPost: (companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdWalletPost', 'companyId', companyId);
            // verify required parameter 'fundId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdWalletPost', 'fundId', fundId);
            // verify required parameter 'fundWallet' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdFundFundIdWalletPost', 'fundWallet', fundWallet);
            const localVarPath = `/company/{company_id}/fund/{fund_id}/wallet`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(fundWallet, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get list of all identities that can be added as Connected accounts to a wallet.
         * @summary Get list of all available exchanges
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesGet: (xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update fund wallet withdraw or transfer policy
         * @summary
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} walletId
         * @param {UpdateWalletPolicyRequest} [updateWalletPolicyRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletPolicy: (companyId, fundId, walletId, updateWalletPolicyRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('updateWalletPolicy', 'companyId', companyId);
            // verify required parameter 'fundId' is not null or undefined
            (0, common_1.assertParamExists)('updateWalletPolicy', 'fundId', fundId);
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('updateWalletPolicy', 'walletId', walletId);
            const localVarPath = `/company/{company_id}/fund/{fund_id}/wallet/{wallet_id}/policy`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)))
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateWalletPolicyRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get wallet info, addresses and balance.
         * @summary Get wallet info
         * @param {string} walletId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdGet: (walletId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('walletWalletIdGet', 'walletId', walletId);
            const localVarPath = `/wallet/{wallet_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get wallet history
         * @summary Get wallet history
         * @param {string} walletId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {number} [since]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdHistoryGet: (walletId, xNonce, xTimestamp, xSign, since, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('walletWalletIdHistoryGet', 'walletId', walletId);
            const localVarPath = `/wallet/{wallet_id}/history`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the max amount that can be moved out of the wallet. Set pending=\"1\" to include unauthorized transactions when calculating the available balance
         * @summary Get wallet max amount with fees
         * @param {string} walletId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {number} [pending]
         * @param {'transfer' | 'withdraw' | 'swap'} [txType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdMaxGet: (walletId, xNonce, xTimestamp, xSign, pending, txType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('walletWalletIdMaxGet', 'walletId', walletId);
            const localVarPath = `/wallet/{wallet_id}/max`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (pending !== undefined) {
                localVarQueryParameter['pending'] = pending;
            }
            if (txType !== undefined) {
                localVarQueryParameter['tx_type'] = txType;
            }
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.WalletApiAxiosParamCreator = WalletApiAxiosParamCreator;
/**
 * WalletApi - functional programming interface
 * @export
 */
const WalletApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.WalletApiAxiosParamCreator)(configuration);
    return {
        /**
         * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
         * @summary Add Wallet to a fund
         * @param {string} companyId
         * @param {string} fundId
         * @param {FundWallet} fundWallet
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get list of all identities that can be added as Connected accounts to a wallet.
         * @summary Get list of all available exchanges
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesGet(xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exchangesGet(xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update fund wallet withdraw or transfer policy
         * @summary
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} walletId
         * @param {UpdateWalletPolicyRequest} [updateWalletPolicyRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletPolicy(companyId, fundId, walletId, updateWalletPolicyRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWalletPolicy(companyId, fundId, walletId, updateWalletPolicyRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get wallet info, addresses and balance.
         * @summary Get wallet info
         * @param {string} walletId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdGet(walletId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.walletWalletIdGet(walletId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get wallet history
         * @summary Get wallet history
         * @param {string} walletId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {number} [since]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdHistoryGet(walletId, xNonce, xTimestamp, xSign, since, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.walletWalletIdHistoryGet(walletId, xNonce, xTimestamp, xSign, since, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns the max amount that can be moved out of the wallet. Set pending=\"1\" to include unauthorized transactions when calculating the available balance
         * @summary Get wallet max amount with fees
         * @param {string} walletId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {number} [pending]
         * @param {'transfer' | 'withdraw' | 'swap'} [txType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdMaxGet(walletId, xNonce, xTimestamp, xSign, pending, txType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.walletWalletIdMaxGet(walletId, xNonce, xTimestamp, xSign, pending, txType, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.WalletApiFp = WalletApiFp;
/**
 * WalletApi - factory interface
 * @export
 */
const WalletApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.WalletApiFp)(configuration);
    return {
        /**
         * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
         * @summary Add Wallet to a fund
         * @param {string} companyId
         * @param {string} fundId
         * @param {FundWallet} fundWallet
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of all identities that can be added as Connected accounts to a wallet.
         * @summary Get list of all available exchanges
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesGet(xNonce, xTimestamp, xSign, options) {
            return localVarFp.exchangesGet(xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Update fund wallet withdraw or transfer policy
         * @summary
         * @param {string} companyId
         * @param {string} fundId
         * @param {string} walletId
         * @param {UpdateWalletPolicyRequest} [updateWalletPolicyRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletPolicy(companyId, fundId, walletId, updateWalletPolicyRequest, options) {
            return localVarFp.updateWalletPolicy(companyId, fundId, walletId, updateWalletPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get wallet info, addresses and balance.
         * @summary Get wallet info
         * @param {string} walletId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdGet(walletId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.walletWalletIdGet(walletId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Get wallet history
         * @summary Get wallet history
         * @param {string} walletId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {number} [since]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdHistoryGet(walletId, xNonce, xTimestamp, xSign, since, options) {
            return localVarFp.walletWalletIdHistoryGet(walletId, xNonce, xTimestamp, xSign, since, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the max amount that can be moved out of the wallet. Set pending=\"1\" to include unauthorized transactions when calculating the available balance
         * @summary Get wallet max amount with fees
         * @param {string} walletId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {number} [pending]
         * @param {'transfer' | 'withdraw' | 'swap'} [txType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdMaxGet(walletId, xNonce, xTimestamp, xSign, pending, txType, options) {
            return localVarFp.walletWalletIdMaxGet(walletId, xNonce, xTimestamp, xSign, pending, txType, options).then((request) => request(axios, basePath));
        },
    };
};
exports.WalletApiFactory = WalletApiFactory;
/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
class WalletApi extends base_1.BaseAPI {
    /**
     * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
     * @summary Add Wallet to a fund
     * @param {string} companyId
     * @param {string} fundId
     * @param {FundWallet} fundWallet
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options) {
        return (0, exports.WalletApiFp)(this.configuration).companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get list of all identities that can be added as Connected accounts to a wallet.
     * @summary Get list of all available exchanges
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    exchangesGet(xNonce, xTimestamp, xSign, options) {
        return (0, exports.WalletApiFp)(this.configuration).exchangesGet(xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update fund wallet withdraw or transfer policy
     * @summary
     * @param {string} companyId
     * @param {string} fundId
     * @param {string} walletId
     * @param {UpdateWalletPolicyRequest} [updateWalletPolicyRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    updateWalletPolicy(companyId, fundId, walletId, updateWalletPolicyRequest, options) {
        return (0, exports.WalletApiFp)(this.configuration).updateWalletPolicy(companyId, fundId, walletId, updateWalletPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get wallet info, addresses and balance.
     * @summary Get wallet info
     * @param {string} walletId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    walletWalletIdGet(walletId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.WalletApiFp)(this.configuration).walletWalletIdGet(walletId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get wallet history
     * @summary Get wallet history
     * @param {string} walletId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {number} [since]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    walletWalletIdHistoryGet(walletId, xNonce, xTimestamp, xSign, since, options) {
        return (0, exports.WalletApiFp)(this.configuration).walletWalletIdHistoryGet(walletId, xNonce, xTimestamp, xSign, since, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the max amount that can be moved out of the wallet. Set pending=\"1\" to include unauthorized transactions when calculating the available balance
     * @summary Get wallet max amount with fees
     * @param {string} walletId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {number} [pending]
     * @param {'transfer' | 'withdraw' | 'swap'} [txType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    walletWalletIdMaxGet(walletId, xNonce, xTimestamp, xSign, pending, txType, options) {
        return (0, exports.WalletApiFp)(this.configuration).walletWalletIdMaxGet(walletId, xNonce, xTimestamp, xSign, pending, txType, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WalletApi = WalletApi;
/**
 * WithdrawalApi - axios parameter creator
 * @export
 */
const WithdrawalApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Initiate a withdrawal and set parameters for the transaction. When a withdrawal transaction is created, custodian(s) need to approve it through their Qredo Signing app. (The number of custodian approvals depends on your Transfer Policy settings.)
         * @summary New withdrawal
         * @param {string} companyId
         * @param {Withdrawal} withdrawal
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdWithdrawPost: (companyId, withdrawal, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdWithdrawPost', 'companyId', companyId);
            // verify required parameter 'withdrawal' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdWithdrawPost', 'withdrawal', withdrawal);
            const localVarPath = `/company/{company_id}/withdraw`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(withdrawal, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Obtain details on a withdrawal status
         * @summary Get withdrawal status
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdWithdrawTxIdGet: (companyId, txId, xNonce, xTimestamp, xSign, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'companyId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdWithdrawTxIdGet', 'companyId', companyId);
            // verify required parameter 'txId' is not null or undefined
            (0, common_1.assertParamExists)('companyCompanyIdWithdrawTxIdGet', 'txId', txId);
            const localVarPath = `/company/{company_id}/withdraw/{tx_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-KEY", configuration);
            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }
            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }
            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.WithdrawalApiAxiosParamCreator = WithdrawalApiAxiosParamCreator;
/**
 * WithdrawalApi - functional programming interface
 * @export
 */
const WithdrawalApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.WithdrawalApiAxiosParamCreator)(configuration);
    return {
        /**
         * Initiate a withdrawal and set parameters for the transaction. When a withdrawal transaction is created, custodian(s) need to approve it through their Qredo Signing app. (The number of custodian approvals depends on your Transfer Policy settings.)
         * @summary New withdrawal
         * @param {string} companyId
         * @param {Withdrawal} withdrawal
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdWithdrawPost(companyId, withdrawal, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdWithdrawPost(companyId, withdrawal, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Obtain details on a withdrawal status
         * @summary Get withdrawal status
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdWithdrawTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.companyCompanyIdWithdrawTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.WithdrawalApiFp = WithdrawalApiFp;
/**
 * WithdrawalApi - factory interface
 * @export
 */
const WithdrawalApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.WithdrawalApiFp)(configuration);
    return {
        /**
         * Initiate a withdrawal and set parameters for the transaction. When a withdrawal transaction is created, custodian(s) need to approve it through their Qredo Signing app. (The number of custodian approvals depends on your Transfer Policy settings.)
         * @summary New withdrawal
         * @param {string} companyId
         * @param {Withdrawal} withdrawal
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdWithdrawPost(companyId, withdrawal, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdWithdrawPost(companyId, withdrawal, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain details on a withdrawal status
         * @summary Get withdrawal status
         * @param {string} companyId
         * @param {string} txId
         * @param {string} [xNonce]
         * @param {string} [xTimestamp]
         * @param {string} [xSign]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdWithdrawTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options) {
            return localVarFp.companyCompanyIdWithdrawTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};
exports.WithdrawalApiFactory = WithdrawalApiFactory;
/**
 * WithdrawalApi - object-oriented interface
 * @export
 * @class WithdrawalApi
 * @extends {BaseAPI}
 */
class WithdrawalApi extends base_1.BaseAPI {
    /**
     * Initiate a withdrawal and set parameters for the transaction. When a withdrawal transaction is created, custodian(s) need to approve it through their Qredo Signing app. (The number of custodian approvals depends on your Transfer Policy settings.)
     * @summary New withdrawal
     * @param {string} companyId
     * @param {Withdrawal} withdrawal
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApi
     */
    companyCompanyIdWithdrawPost(companyId, withdrawal, xNonce, xTimestamp, xSign, options) {
        return (0, exports.WithdrawalApiFp)(this.configuration).companyCompanyIdWithdrawPost(companyId, withdrawal, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Obtain details on a withdrawal status
     * @summary Get withdrawal status
     * @param {string} companyId
     * @param {string} txId
     * @param {string} [xNonce]
     * @param {string} [xTimestamp]
     * @param {string} [xSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApi
     */
    companyCompanyIdWithdrawTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options) {
        return (0, exports.WithdrawalApiFp)(this.configuration).companyCompanyIdWithdrawTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WithdrawalApi = WithdrawalApi;
