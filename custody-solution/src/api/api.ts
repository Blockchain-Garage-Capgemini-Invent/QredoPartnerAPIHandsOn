/* tslint:disable */
/* eslint-disable */
/**
 * Qredo Partner & Core Client API
 * The Qredo Partner API provisions and manages Qredo services. It can be used by Partners to setup and manage client accounts. The Core Client API enables transactions to be initiated and signed. <br>   Note, two servers are provided:   - API Server base path https://api.qredo.network/api/v1/p   - Sandbox server base path https://sandbox-api.qredo.network/api/v1/p 
 *
 * The version of the OpenAPI document: 1.1.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * ActionDetailApproveNewWalletConnect provides details of a new wallet connect
 * @export
 * @interface ActionDetailApproveNewWalletConnect
 */
export interface ActionDetailApproveNewWalletConnect {
    /**
     * 
     * @type {ActionDetailApproveNewWalletConnectClientData}
     * @memberof ActionDetailApproveNewWalletConnect
     */
    'clientData'?: ActionDetailApproveNewWalletConnectClientData;
    /**
     * 
     * @type {ActionDetailApproveNewWalletConnectWallet}
     * @memberof ActionDetailApproveNewWalletConnect
     */
    'wallet'?: ActionDetailApproveNewWalletConnectWallet;
}
/**
 * 
 * @export
 * @interface ActionDetailApproveNewWalletConnectClientData
 */
export interface ActionDetailApproveNewWalletConnectClientData {
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveNewWalletConnectClientData
     */
    'customProperty1'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveNewWalletConnectClientData
     */
    'customProperty2'?: string;
}
/**
 * 
 * @export
 * @interface ActionDetailApproveNewWalletConnectWallet
 */
export interface ActionDetailApproveNewWalletConnectWallet {
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveNewWalletConnectWallet
     */
    'walletID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveNewWalletConnectWallet
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveNewWalletConnectWallet
     */
    'asset'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActionDetailApproveNewWalletConnectWallet
     */
    'type'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveNewWalletConnectWallet
     */
    'typeCode'?: string;
}
/**
 * ActionDetailApproveTransfer provides details of an approval transfer
 * @export
 * @interface ActionDetailApproveTransfer
 */
export interface ActionDetailApproveTransfer {
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'txType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'txID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'asset'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActionDetailApproveTransfer
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActionDetailApproveTransfer
     */
    'fees'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActionDetailApproveTransfer
     */
    'netAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'reference'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'benefitOf'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'accountNo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'companyID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'fundID'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActionDetailApproveTransfer
     */
    'initiatedTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActionDetailApproveTransfer
     */
    'expires'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'recipientID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'recipientName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'initiatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'initiatorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveTransfer
     */
    'initiatorType'?: string;
}
/**
 * ActionDetailApproveWithdraw provides details of an approval withdrawal
 * @export
 * @interface ActionDetailApproveWithdraw
 */
export interface ActionDetailApproveWithdraw {
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'txType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'txID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'asset'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActionDetailApproveWithdraw
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActionDetailApproveWithdraw
     */
    'fees'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActionDetailApproveWithdraw
     */
    'netAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'reference'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'benefitOf'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'accountNo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'companyID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'fundID'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActionDetailApproveWithdraw
     */
    'initiatedTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActionDetailApproveWithdraw
     */
    'expires'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'recipientAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'recipientAddressName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'initiatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'initiatorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDetailApproveWithdraw
     */
    'initiatorType'?: string;
}
/**
 * 
 * @export
 * @interface ActionDetails
 */
export interface ActionDetails {
    /**
     * The ID of the action
     * @type {string}
     * @memberof ActionDetails
     */
    'id'?: string;
    /**
     * The action type
     * @type {string}
     * @memberof ActionDetails
     */
    'type'?: ActionDetailsTypeEnum;
    /**
     * The action status
     * @type {string}
     * @memberof ActionDetails
     */
    'status'?: ActionDetailsStatusEnum;
    /**
     * The create time in epoch
     * @type {number}
     * @memberof ActionDetails
     */
    'timestamp'?: number;
    /**
     * The expire time in epoch
     * @type {number}
     * @memberof ActionDetails
     */
    'expireTime'?: number;
    /**
     * 
     * @type {ActionDetailsDetails}
     * @memberof ActionDetails
     */
    'details'?: ActionDetailsDetails;
}

export const ActionDetailsTypeEnum = {
    ApproveWithdraw: 'ApproveWithdraw',
    ApproveTransfer: 'ApproveTransfer'
} as const;

export type ActionDetailsTypeEnum = typeof ActionDetailsTypeEnum[keyof typeof ActionDetailsTypeEnum];
export const ActionDetailsStatusEnum = {
    Pending: 'pending',
    Expired: 'expired',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type ActionDetailsStatusEnum = typeof ActionDetailsStatusEnum[keyof typeof ActionDetailsStatusEnum];

/**
 * @type ActionDetailsDetails
 * @export
 */
export type ActionDetailsDetails = ActionDetailApproveNewWalletConnect | ActionDetailApproveTransfer | ActionDetailApproveWithdraw;

/**
 * 
 * @export
 * @interface ActionInfo
 */
export interface ActionInfo {
    /**
     * The ID of the action
     * @type {string}
     * @memberof ActionInfo
     */
    'id'?: string;
    /**
     * The action type
     * @type {string}
     * @memberof ActionInfo
     */
    'type'?: ActionInfoTypeEnum;
    /**
     * The action status
     * @type {string}
     * @memberof ActionInfo
     */
    'status'?: ActionInfoStatusEnum;
    /**
     * The create time in epoch
     * @type {number}
     * @memberof ActionInfo
     */
    'timestamp'?: number;
    /**
     * The expire time in epoch
     * @type {number}
     * @memberof ActionInfo
     */
    'expireTime'?: number;
}

export const ActionInfoTypeEnum = {
    ApproveWithdraw: 'ApproveWithdraw',
    ApproveTransfer: 'ApproveTransfer'
} as const;

export type ActionInfoTypeEnum = typeof ActionInfoTypeEnum[keyof typeof ActionInfoTypeEnum];
export const ActionInfoStatusEnum = {
    Pending: 'pending',
    Expired: 'expired',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type ActionInfoStatusEnum = typeof ActionInfoStatusEnum[keyof typeof ActionInfoStatusEnum];

/**
 * 
 * @export
 * @interface ActionsInfo
 */
export interface ActionsInfo {
    /**
     * 
     * @type {number}
     * @memberof ActionsInfo
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActionInfo>}
     * @memberof ActionsInfo
     */
    'actions'?: Array<ActionInfo>;
}
/**
 * Add a whitelisted address to a fund.
 * @export
 * @interface AddFundWhitelist
 */
export interface AddFundWhitelist {
    /**
     * 
     * @type {string}
     * @memberof AddFundWhitelist
     */
    'asset'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddFundWhitelist
     */
    'address'?: string;
    /**
     * Name of the whitelist address.
     * @type {string}
     * @memberof AddFundWhitelist
     */
    'name'?: string;
}
/**
 * Add a transaction to the liquidity hub.
 * @export
 * @interface AddToLiquidityHub
 */
export interface AddToLiquidityHub {
    /**
     * 
     * @type {string}
     * @memberof AddToLiquidityHub
     */
    'tx_id'?: string;
}
/**
 * 
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * Code of the network.
     * @type {string}
     * @memberof Asset
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'name'?: string;
    /**
     * Code of the currency.
     * @type {string}
     * @memberof Asset
     */
    'unitCode'?: string;
}
/**
 * 
 * @export
 * @interface AssetAmount
 */
export interface AssetAmount {
    /**
     * This is a symbol of the cryptocurrency or tokenized asset, e.g., BTC for Bitcoin.
     * @type {string}
     * @memberof AssetAmount
     */
    'symbol': string;
    /**
     * The amount of each cryptocurrency or tokenized asset in Satoshis. Satoshi figures are in whole numbers.
     * @type {number}
     * @memberof AssetAmount
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface Assets
 */
export interface Assets {
    /**
     * 
     * @type {AssetsList}
     * @memberof Assets
     */
    'assets'?: AssetsList;
}
/**
 * 
 * @export
 * @interface AssetsList
 */
export interface AssetsList {
    /**
     * 
     * @type {string}
     * @memberof AssetsList
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetsList
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetsList
     */
    'unitCode'?: string;
    /**
     * Unit scale.
     * @type {number}
     * @memberof AssetsList
     */
    'scale'?: number;
    /**
     * Unit enabled
     * @type {boolean}
     * @memberof AssetsList
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface AtomicSwapMake
 */
export interface AtomicSwapMake {
    /**
     * 
     * @type {string}
     * @memberof AtomicSwapMake
     */
    'send_wallet_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AtomicSwapMake
     */
    'receive_wallet_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AtomicSwapMake
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof AtomicSwapMake
     */
    'partner_txID'?: string;
    /**
     * The time in Epoch when the withdrawal will expire if it doesn\'t get approved by the custodians.
     * @type {string}
     * @memberof AtomicSwapMake
     */
    'expires'?: string;
    /**
     * 
     * @type {Send2}
     * @memberof AtomicSwapMake
     */
    'send'?: Send2;
    /**
     * 
     * @type {Receive}
     * @memberof AtomicSwapMake
     */
    'receive'?: Receive;
    /**
     * 
     * @type {boolean}
     * @memberof AtomicSwapMake
     */
    'add_to_liquidity_hub'?: boolean;
}
/**
 * 
 * @export
 * @interface AtomicSwapTake
 */
export interface AtomicSwapTake {
    /**
     * 
     * @type {string}
     * @memberof AtomicSwapTake
     */
    'send_wallet_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AtomicSwapTake
     */
    'receive_wallet_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AtomicSwapTake
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof AtomicSwapTake
     */
    'partner_txID'?: string;
}
/**
 * 
 * @export
 * @interface Company
 */
export interface Company {
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'city'?: string;
    /**
     * ISO 3166-1 country code
     * @type {string}
     * @memberof Company
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'domain'?: string;
    /**
     * Company reference ID
     * @type {string}
     * @memberof Company
     */
    'ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'company_id'?: string;
}
/**
 * 
 * @export
 * @interface CompanySearchResponse
 */
export interface CompanySearchResponse {
    /**
     * Total count in integer format of the number of matches for a company search.
     * @type {number}
     * @memberof CompanySearchResponse
     */
    'total_count'?: number;
    /**
     * Array showing details of each matching company that comprises the total count.
     * @type {Array<CompanySearchResponseMatchesInner>}
     * @memberof CompanySearchResponse
     */
    'matches'?: Array<CompanySearchResponseMatchesInner>;
}
/**
 * 
 * @export
 * @interface CompanySearchResponseMatchesInner
 */
export interface CompanySearchResponseMatchesInner {
    /**
     * 
     * @type {string}
     * @memberof CompanySearchResponseMatchesInner
     */
    'company_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanySearchResponseMatchesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanySearchResponseMatchesInner
     */
    'domain'?: string;
}
/**
 * Connect external counterparty
 * @export
 * @interface ConnectAccount
 */
export interface ConnectAccount {
    /**
     * 
     * @type {string}
     * @memberof ConnectAccount
     */
    'counterparty_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectAccount
     */
    'client_id'?: string;
}
/**
 * 
 * @export
 * @interface ConnectedExternalCounterpartiesInner
 */
export interface ConnectedExternalCounterpartiesInner {
    /**
     * 
     * @type {string}
     * @memberof ConnectedExternalCounterpartiesInner
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectedExternalCounterpartiesInner
     */
    'counterparty_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectedExternalCounterpartiesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectedExternalCounterpartiesInner
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface CoreClientInfo
 */
export interface CoreClientInfo {
    /**
     * 
     * @type {string}
     * @memberof CoreClientInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreClientInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreClientInfo
     */
    'feed'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreClientInfo
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface CoreClientSign
 */
export interface CoreClientSign {
    /**
     * 
     * @type {string}
     * @memberof CoreClientSign
     */
    'message_hash_hex'?: string;
}
/**
 * 
 * @export
 * @interface CoreClientSignature
 */
export interface CoreClientSignature {
    /**
     * 
     * @type {string}
     * @memberof CoreClientSignature
     */
    'signature_hex'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreClientSignature
     */
    'signer_id'?: string;
}
/**
 * 
 * @export
 * @interface CoreClientVerifySignature
 */
export interface CoreClientVerifySignature {
    /**
     * 
     * @type {string}
     * @memberof CoreClientVerifySignature
     */
    'message_hash_hex'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreClientVerifySignature
     */
    'signature_hex'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreClientVerifySignature
     */
    'signer_id'?: string;
}
/**
 * 
 * @export
 * @interface CoreClientWallet
 */
export interface CoreClientWallet {
    /**
     * 
     * @type {string}
     * @memberof CoreClientWallet
     */
    'wallet_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreClientWallet
     */
    'action_id'?: string;
    /**
     * The action status
     * @type {string}
     * @memberof CoreClientWallet
     */
    'status'?: CoreClientWalletStatusEnum;
    /**
     * The expire time in epoch
     * @type {number}
     * @memberof CoreClientWallet
     */
    'expires'?: number;
}

export const CoreClientWalletStatusEnum = {
    Pending: 'pending',
    Expired: 'expired',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type CoreClientWalletStatusEnum = typeof CoreClientWalletStatusEnum[keyof typeof CoreClientWalletStatusEnum];

/**
 * 
 * @export
 * @interface CoreClientsInfo
 */
export interface CoreClientsInfo {
    /**
     * 
     * @type {number}
     * @memberof CoreClientsInfo
     */
    'count'?: number;
    /**
     * 
     * @type {Array<CoreClientInfo>}
     * @memberof CoreClientsInfo
     */
    'clients'?: Array<CoreClientInfo>;
}
/**
 * 
 * @export
 * @interface CoreclientClientIdWalletsGet200Response
 */
export interface CoreclientClientIdWalletsGet200Response {
    /**
     * 
     * @type {Array<CoreClientWallet>}
     * @memberof CoreclientClientIdWalletsGet200Response
     */
    'wallets'?: Array<CoreClientWallet>;
}
/**
 * 
 * @export
 * @interface CoreclientFinishPostRequest
 */
export interface CoreclientFinishPostRequest {
    /**
     * 
     * @type {string}
     * @memberof CoreclientFinishPostRequest
     */
    'idDocSignatureHex'?: string;
}
/**
 * A Company ID is generated when a new company is created.
 * @export
 * @interface CreateCompanyResponse
 */
export interface CreateCompanyResponse {
    /**
     * Company reference ID
     * @type {string}
     * @memberof CreateCompanyResponse
     */
    'ref': string;
    /**
     * Company ID
     * @type {string}
     * @memberof CreateCompanyResponse
     */
    'company_id': string;
}
/**
 * 
 * @export
 * @interface CreateFundResponse
 */
export interface CreateFundResponse {
    /**
     * The ID of the newly created fund
     * @type {string}
     * @memberof CreateFundResponse
     */
    'fund_id'?: string;
    /**
     * ID for the custody group of withdraw.
     * @type {string}
     * @memberof CreateFundResponse
     */
    'custodygroup_withdraw'?: string;
    /**
     * ID for the custody group of transfer.
     * @type {string}
     * @memberof CreateFundResponse
     */
    'custodygroup_tx'?: string;
}
/**
 * 
 * @export
 * @interface Custodygroup
 */
export interface Custodygroup {
    /**
     * 
     * @type {string}
     * @memberof Custodygroup
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Custodygroup
     */
    'threshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof Custodygroup
     */
    'members_count'?: number;
    /**
     * 
     * @type {Array<CustodygroupMember>}
     * @memberof Custodygroup
     */
    'members'?: Array<CustodygroupMember>;
}
/**
 * 
 * @export
 * @interface CustodygroupMember
 */
export interface CustodygroupMember {
    /**
     * 
     * @type {string}
     * @memberof CustodygroupMember
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustodygroupMember
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustodygroupMember
     */
    'lastName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustodygroupMember
     */
    'required'?: boolean;
}
/**
 * 
 * @export
 * @interface CustodygroupSearchResult
 */
export interface CustodygroupSearchResult {
    /**
     * 
     * @type {number}
     * @memberof CustodygroupSearchResult
     */
    'total_count'?: number;
    /**
     * 
     * @type {Array<CustodygroupSearchResultListInner>}
     * @memberof CustodygroupSearchResult
     */
    'list'?: Array<CustodygroupSearchResultListInner>;
}
/**
 * 
 * @export
 * @interface CustodygroupSearchResultListInner
 */
export interface CustodygroupSearchResultListInner {
    /**
     * 
     * @type {string}
     * @memberof CustodygroupSearchResultListInner
     */
    'custody_group_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustodygroupSearchResultListInner
     */
    'fund_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustodygroupSearchResultListInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface DepositAddress
 */
export interface DepositAddress {
    /**
     * This declares the wallet type, which is specified by currency. Example is BTC or ETH.
     * @type {string}
     * @memberof DepositAddress
     */
    'wallet_type': string;
    /**
     * This is the fund id (from Fund API) to assign the wallet address to.
     * @type {string}
     * @memberof DepositAddress
     */
    'fund_id': string;
}
/**
 * 
 * @export
 * @interface DepositAddressDetail
 */
export interface DepositAddressDetail {
    /**
     * This declares the wallet type, which is specified by currency. Example is BTC or ETH.
     * @type {string}
     * @memberof DepositAddressDetail
     */
    'wallet_type': string;
    /**
     * This is the fund id (from Fund API) to assign the wallet address to.
     * @type {string}
     * @memberof DepositAddressDetail
     */
    'fund_id': string;
    /**
     * Deposit wallet address
     * @type {string}
     * @memberof DepositAddressDetail
     */
    'address': string;
    /**
     * The amount of currency in the wallet.
     * @type {number}
     * @memberof DepositAddressDetail
     */
    'amount': number;
    /**
     * 
     * @type {FundDetail}
     * @memberof DepositAddressDetail
     */
    'fund': FundDetail;
}
/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'accountCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'initials'?: string;
    /**
     * 
     * @type {EntityType}
     * @memberof Entity
     */
    'type'?: EntityType;
    /**
     * 
     * @type {EntityCompany}
     * @memberof Entity
     */
    'company'?: EntityCompany | null;
    /**
     * 
     * @type {EntityUser}
     * @memberof Entity
     */
    'user'?: EntityUser | null;
    /**
     * 
     * @type {EntityCompany}
     * @memberof Entity
     */
    'core-client'?: EntityCompany | null;
}


/**
 * 
 * @export
 * @interface EntityCompany
 */
export interface EntityCompany {
    /**
     * 
     * @type {string}
     * @memberof EntityCompany
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EntityType = {
    User: 'user',
    Company: 'company',
    CoreClient: 'core-client'
} as const;

export type EntityType = typeof EntityType[keyof typeof EntityType];


/**
 * 
 * @export
 * @interface EntityUser
 */
export interface EntityUser {
    /**
     * 
     * @type {string}
     * @memberof EntityUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityUser
     */
    'userName'?: string;
}
/**
 * 
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface ExchangesList
 */
export interface ExchangesList {
    /**
     * 
     * @type {Array<ExchangesListExchangesInner>}
     * @memberof ExchangesList
     */
    'exchanges'?: Array<ExchangesListExchangesInner>;
}
/**
 * 
 * @export
 * @interface ExchangesListExchangesInner
 */
export interface ExchangesListExchangesInner {
    /**
     * 
     * @type {string}
     * @memberof ExchangesListExchangesInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangesListExchangesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangesListExchangesInner
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangesListExchangesInner
     */
    'logourl'?: string;
}
/**
 * 
 * @export
 * @interface FeesRequest
 */
export interface FeesRequest {
    /**
     * 
     * @type {string}
     * @memberof FeesRequest
     */
    'type'?: FeesRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FeesRequest
     */
    'asset'?: string;
    /**
     * 
     * @type {number}
     * @memberof FeesRequest
     */
    'amount'?: number;
}

export const FeesRequestTypeEnum = {
    Withdraw: 'withdraw',
    TransferOut: 'transferOut',
    Swap: 'swap'
} as const;

export type FeesRequestTypeEnum = typeof FeesRequestTypeEnum[keyof typeof FeesRequestTypeEnum];

/**
 * 
 * @export
 * @interface FeesResponse
 */
export interface FeesResponse {
    /**
     * 
     * @type {number}
     * @memberof FeesResponse
     */
    'netAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof FeesResponse
     */
    'amountToSend'?: number;
    /**
     * 
     * @type {number}
     * @memberof FeesResponse
     */
    'fees'?: number;
}
/**
 * A fund is the organisational unit that customers assign their portfolios into. Administrators, Principals and Custody Groups are assigned to each individual fund. There is only one Custody Group per Fund.
 * @export
 * @interface Fund
 */
export interface Fund {
    /**
     * The name of the fund.
     * @type {string}
     * @memberof Fund
     */
    'name': string;
    /**
     * A description for the fund.
     * @type {string}
     * @memberof Fund
     */
    'description'?: string;
    /**
     * 
     * @type {NewCustodyGroup}
     * @memberof Fund
     */
    'custodygroup_withdraw'?: NewCustodyGroup;
    /**
     * 
     * @type {NewCustodyGroup}
     * @memberof Fund
     */
    'custodygroup_tx'?: NewCustodyGroup;
    /**
     * 
     * @type {Array<NewWallet>}
     * @memberof Fund
     */
    'wallets'?: Array<NewWallet>;
}
/**
 * 
 * @export
 * @interface FundAsset
 */
export interface FundAsset {
    /**
     * 
     * @type {Array<string>}
     * @memberof FundAsset
     */
    'assets'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FundDepositResponse
 */
export interface FundDepositResponse {
    /**
     * 
     * @type {number}
     * @memberof FundDepositResponse
     */
    'total_count'?: number;
    /**
     * 
     * @type {Array<ListInner>}
     * @memberof FundDepositResponse
     */
    'list'?: Array<ListInner>;
}
/**
 * A fund is the organisational unit that customers assign their portfolios into. Administrators, Principals and Custody Groups are assigned to each individual fund. There is only one Custody Group per Fund.
 * @export
 * @interface FundDetail
 */
export interface FundDetail {
    /**
     * 
     * @type {string}
     * @memberof FundDetail
     */
    'fund_id'?: string;
    /**
     * The name of the fund.
     * @type {string}
     * @memberof FundDetail
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundDetail
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundDetail
     */
    'custodygroup_withdraw'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundDetail
     */
    'custodygroup_tx'?: string;
    /**
     * 
     * @type {Policy}
     * @memberof FundDetail
     */
    'policy_withdraw'?: Policy;
    /**
     * 
     * @type {Policy}
     * @memberof FundDetail
     */
    'policy_tx'?: Policy;
    /**
     * 
     * @type {Array<FundMember>}
     * @memberof FundDetail
     */
    'members'?: Array<FundMember>;
    /**
     * The fund\'s asset types
     * @type {Array<string>}
     * @memberof FundDetail
     */
    'assets'?: Array<string>;
    /**
     * The fund\'s wallets
     * @type {Array<FundWalletInfo>}
     * @memberof FundDetail
     */
    'wallets'?: Array<FundWalletInfo>;
}
/**
 * 
 * @export
 * @interface FundHistoryItem
 */
export interface FundHistoryItem {
    /**
     * 
     * @type {string}
     * @memberof FundHistoryItem
     */
    'wallet_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundHistoryItem
     */
    'tx_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundHistoryItem
     */
    'chain_tx_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundHistoryItem
     */
    'asset'?: string;
    /**
     * 
     * @type {number}
     * @memberof FundHistoryItem
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof FundHistoryItem
     */
    'fee'?: number;
    /**
     * 
     * @type {number}
     * @memberof FundHistoryItem
     */
    'net_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof FundHistoryItem
     */
    'timestamp'?: number;
}
/**
 * A fund member is a user who has certain permissions within a fund
 * @export
 * @interface FundMember
 */
export interface FundMember {
    /**
     * 
     * @type {Entity}
     * @memberof FundMember
     */
    'entity'?: Entity;
    /**
     * 
     * @type {Permissions}
     * @memberof FundMember
     */
    'permissions'?: Permissions;
}
/**
 * 
 * @export
 * @interface FundMembersList
 */
export interface FundMembersList {
    /**
     * 
     * @type {number}
     * @memberof FundMembersList
     */
    'total_count': number;
    /**
     * 
     * @type {FundMembersListList}
     * @memberof FundMembersList
     */
    'list': FundMembersListList;
}
/**
 * 
 * @export
 * @interface FundMembersListList
 */
export interface FundMembersListList {
    /**
     * 
     * @type {string}
     * @memberof FundMembersListList
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundMembersListList
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundMembersListList
     */
    'lastName'?: string;
    /**
     * 
     * @type {number}
     * @memberof FundMembersListList
     */
    'created'?: number;
    /**
     * 
     * @type {Permissions}
     * @memberof FundMembersListList
     */
    'permissions'?: Permissions;
}
/**
 * Fund seearch result
 * @export
 * @interface FundSearchResult
 */
export interface FundSearchResult {
    /**
     * Total count in integer format of the number of funds.
     * @type {number}
     * @memberof FundSearchResult
     */
    'total_count'?: number;
    /**
     * Array showing details of each fund.
     * @type {Array<ListInner1>}
     * @memberof FundSearchResult
     */
    'list'?: Array<ListInner1>;
}
/**
 * 
 * @export
 * @interface FundWallet
 */
export interface FundWallet {
    /**
     * 
     * @type {Array<NewWallet>}
     * @memberof FundWallet
     */
    'wallets'?: Array<NewWallet>;
}
/**
 * 
 * @export
 * @interface FundWalletHistory
 */
export interface FundWalletHistory {
    /**
     * 
     * @type {Array<FundHistoryItem>}
     * @memberof FundWalletHistory
     */
    'history'?: Array<FundHistoryItem>;
}
/**
 * 
 * @export
 * @interface FundWalletInfo
 */
export interface FundWalletInfo {
    /**
     * 
     * @type {string}
     * @memberof FundWalletInfo
     */
    'wallet_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundWalletInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundWalletInfo
     */
    'asset'?: string;
    /**
     * Wallet type:   * `0` - Standard wallet   * `1` - Dedicated wallet   * `2` - Multi-counterparty wallet 
     * @type {number}
     * @memberof FundWalletInfo
     */
    'type'?: number;
    /**
     * 
     * @type {string}
     * @memberof FundWalletInfo
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundWalletInfo
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundWalletInfo
     */
    'address_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundWalletInfo
     */
    'short_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof FundWalletInfo
     */
    'balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof FundWalletInfo
     */
    'custodygroup_withdraw'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundWalletInfo
     */
    'custodygroup_tx'?: string;
    /**
     * 
     * @type {Policy}
     * @memberof FundWalletInfo
     */
    'policy_withdraw'?: Policy;
    /**
     * 
     * @type {Policy}
     * @memberof FundWalletInfo
     */
    'policy_tx'?: Policy;
    /**
     * 
     * @type {Array<ConnectedExternalCounterpartiesInner>}
     * @memberof FundWalletInfo
     */
    'connected'?: Array<ConnectedExternalCounterpartiesInner> | null;
}
/**
 * List of whitelisted addresses for a fund.
 * @export
 * @interface FundWhitelist
 */
export interface FundWhitelist {
    /**
     * Total count in integer format of the number of whitelisted addresses in a fund.
     * @type {number}
     * @memberof FundWhitelist
     */
    'total_count'?: number;
    /**
     * Array showing details of each whitelisted address.
     * @type {Array<ListInner2>}
     * @memberof FundWhitelist
     */
    'list'?: Array<ListInner2>;
}
/**
 * 
 * @export
 * @interface GetCoreclientActionActionId200Response
 */
export interface GetCoreclientActionActionId200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetCoreclientActionActionId200Response
     */
    'messages'?: Array<string>;
}
/**
 * View all assets held by a company’s fund.
 * @export
 * @interface Holding
 */
export interface Holding {
    /**
     * This is a symbol of the cryptocurrencies or securities held within the fund. For example, the symbol for Bitcoin is BTC.
     * @type {string}
     * @memberof Holding
     */
    'symbol'?: string;
    /**
     * The amount of each cryptocurrency or tokenized asset.
     * @type {number}
     * @memberof Holding
     */
    'amount': number;
}
/**
 * View all holdings across all funds held by a customer.
 * @export
 * @interface Holdings
 */
export interface Holdings {
    /**
     * 
     * @type {Array<Holding>}
     * @memberof Holdings
     */
    'holdings': Array<Holding>;
}
/**
 * 
 * @export
 * @interface InviteUser
 */
export interface InviteUser {
    /**
     * The email of the user to be invited
     * @type {string}
     * @memberof InviteUser
     */
    'recipient_email': string;
    /**
     * The ID of the sender of the invitation whose first and last names will be included in the invitation.
     * @type {string}
     * @memberof InviteUser
     */
    'sender_id': string;
    /**
     * This declares whether a user is an admin or not. Users with admin privileges can create trading spaces.
     * @type {boolean}
     * @memberof InviteUser
     */
    'space_admin': boolean;
}
/**
 * 
 * @export
 * @interface Items
 */
export interface Items {
    /**
     * 
     * @type {string}
     * @memberof Items
     */
    'tx_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Items
     */
    'send_asset'?: string;
    /**
     * 
     * @type {number}
     * @memberof Items
     */
    'send_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Items
     */
    'receive_asset'?: string;
    /**
     * 
     * @type {number}
     * @memberof Items
     */
    'receive_amount'?: number;
    /**
     * Returns true if the transaction\'s maker is the current company
     * @type {boolean}
     * @memberof Items
     */
    'owner'?: boolean;
    /**
     * Timestamp of when the transaction was added to the liquidity hub.
     * @type {number}
     * @memberof Items
     */
    'added'?: number;
    /**
     * Timestamp of when the transaction expires.
     * @type {number}
     * @memberof Items
     */
    'expires'?: number;
}
/**
 * Liquidity hub items.
 * @export
 * @interface LiquidityHub
 */
export interface LiquidityHub {
    /**
     * 
     * @type {Items}
     * @memberof LiquidityHub
     */
    'items'?: Items;
}
/**
 * 
 * @export
 * @interface ListInner
 */
export interface ListInner {
    /**
     * Name of asset
     * @type {string}
     * @memberof ListInner
     */
    'asset'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListInner
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListInner
     */
    'balance'?: number;
}
/**
 * 
 * @export
 * @interface ListInner1
 */
export interface ListInner1 {
    /**
     * Name of the Fund.
     * @type {string}
     * @memberof ListInner1
     */
    'name'?: string;
    /**
     * fund ID.
     * @type {string}
     * @memberof ListInner1
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ListInner2
 */
export interface ListInner2 {
    /**
     * 
     * @type {string}
     * @memberof ListInner2
     */
    'asset'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListInner2
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListInner2
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ListInner3
 */
export interface ListInner3 {
    /**
     * User ID
     * @type {string}
     * @memberof ListInner3
     */
    'user_id'?: string;
    /**
     * User first name.
     * @type {string}
     * @memberof ListInner3
     */
    'firstName'?: string;
    /**
     * User last name.
     * @type {string}
     * @memberof ListInner3
     */
    'lastName'?: string;
    /**
     * User email address.
     * @type {string}
     * @memberof ListInner3
     */
    'email'?: string;
    /**
     * User mobile number address.
     * @type {string}
     * @memberof ListInner3
     */
    'phone'?: string;
    /**
     * This declares whether a user is an admin or not. Users with admin privileges can create trading spaces.
     * @type {number}
     * @memberof ListInner3
     */
    'space_admin'?: number;
    /**
     * User Status indicates the stage an end user is at during the signup process. Example, 0 is not invited, 1 invite sent
     * @type {number}
     * @memberof ListInner3
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'msg'?: string;
    /**
     * 
     * @type {ErrorDetail}
     * @memberof ModelError
     */
    'detail'?: ErrorDetail;
}
/**
 * 
 * @export
 * @interface NewCoreClient
 */
export interface NewCoreClient {
    /**
     * 
     * @type {string}
     * @memberof NewCoreClient
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface NewCustodyGroup
 */
export interface NewCustodyGroup {
    /**
     * Minimum number of custodian approval signatures out of the total number for a transaction to happen.
     * @type {number}
     * @memberof NewCustodyGroup
     */
    'threshold'?: number;
    /**
     * Members that are assigned as custodians to approve withdrawal transactions. As members need to be trusted party users for the company of the fund, the id you add is the trusted_party_id.
     * @type {Array<string>}
     * @memberof NewCustodyGroup
     */
    'members'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NewWallet
 */
export interface NewWallet {
    /**
     * 
     * @type {string}
     * @memberof NewWallet
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWallet
     */
    'asset'?: string;
    /**
     * 
     * @type {NewWalletCustodygroupWithdraw}
     * @memberof NewWallet
     */
    'custodygroup_withdraw'?: NewWalletCustodygroupWithdraw;
    /**
     * 
     * @type {NewWalletCustodygroupWithdraw}
     * @memberof NewWallet
     */
    'custodygroup_tx'?: NewWalletCustodygroupWithdraw;
    /**
     * Wallet type:   * `0` - Standard wallet   * `1` - Dedicated wallet   * `2` - Multi-counterparty wallet 
     * @type {number}
     * @memberof NewWallet
     */
    'type'?: number;
    /**
     * 
     * @type {Array<ConnectAccount>}
     * @memberof NewWallet
     */
    'connect'?: Array<ConnectAccount> | null;
}
/**
 * @type NewWalletCustodygroupWithdraw
 * @export
 */
export type NewWalletCustodygroupWithdraw = NewCustodyGroup | any;

/**
 * 
 * @export
 * @interface OkResponse
 */
export interface OkResponse {
    /**
     * 
     * @type {number}
     * @memberof OkResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof OkResponse
     */
    'msg'?: string;
}
/**
 * A map of permissions
 * @export
 * @interface Permissions
 */
export interface Permissions {
    /**
     * True means the member is an admin. False means the member is not an admin.
     * @type {boolean}
     * @memberof Permissions
     */
    'admin'?: boolean;
    /**
     * True means the member can initiate a withdrawal. False means the member cannot initiate a withdrawal.
     * @type {boolean}
     * @memberof Permissions
     */
    'withdraw'?: boolean;
    /**
     * True means the member can initiate a transfer. False means the member cannot initiate a transfer.
     * @type {boolean}
     * @memberof Permissions
     */
    'transfer'?: boolean;
    /**
     * True means the member can initiate a swap. False means the member cannot initiate a swap.
     * @type {boolean}
     * @memberof Permissions
     */
    'swap'?: boolean;
}
/**
 * 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    'name'?: string;
    /**
     * Minimum number of custodian approval signatures out of the total number for a transaction to happen.
     * @type {number}
     * @memberof Policy
     */
    'threshold'?: number;
    /**
     * Members that are assigned as custodians to approve transactions..
     * @type {Array<Entity>}
     * @memberof Policy
     */
    'members'?: Array<Entity>;
}
/**
 * 
 * @export
 * @interface PutCoreclientActionActionIdRequest
 */
export interface PutCoreclientActionActionIdRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof PutCoreclientActionActionIdRequest
     */
    'signatures'?: Array<string>;
}
/**
 * This is the type and amount of cryptocurrency send from the Taker to the Maker. This is defined as \'symbol\' within the Fund schema.
 * @export
 * @interface Receive
 */
export interface Receive {
    /**
     * This is a symbol of the cryptocurrency or tokenized asset, e.g., BTC for Bitcoin.
     * @type {string}
     * @memberof Receive
     */
    'symbol': string;
    /**
     * The amount of each cryptocurrency or tokenized asset in Satoshis. Satoshi figures are in whole numbers.
     * @type {number}
     * @memberof Receive
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface Request
 */
export interface Request {
    /**
     * 
     * @type {string}
     * @memberof Request
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Request
     */
    'blsPublicKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof Request
     */
    'ecPublicKey'?: string;
}
/**
 * This is the type and amount of cryptocurrency or tokenized asset in Satoshi sent from the trade initiator to the receiving counterparty. Satoshi figures are in whole numbers.
 * @export
 * @interface Send
 */
export interface Send {
    /**
     * This is a symbol of the cryptocurrency or tokenized asset, e.g., BTC for Bitcoin.
     * @type {string}
     * @memberof Send
     */
    'symbol': string;
    /**
     * The amount of each cryptocurrency or tokenized asset in Satoshis. Satoshi figures are in whole numbers.
     * @type {number}
     * @memberof Send
     */
    'amount': number;
}
/**
 * This is the type and amount of cryptocurrency sent from initiating Principal to Beneficiary. This is defined as \'symbol\' within the Fund schema.
 * @export
 * @interface Send1
 */
export interface Send1 {
    /**
     * This is a symbol of the cryptocurrency or tokenized asset, e.g., BTC for Bitcoin.
     * @type {string}
     * @memberof Send1
     */
    'symbol': string;
    /**
     * The amount of each cryptocurrency or tokenized asset in Satoshis. Satoshi figures are in whole numbers.
     * @type {number}
     * @memberof Send1
     */
    'amount': number;
}
/**
 * This is the type and amount of cryptocurrency sent from the Maker to the Taker. This is defined as \'symbol\' within the Fund schema.
 * @export
 * @interface Send2
 */
export interface Send2 {
    /**
     * This is a symbol of the cryptocurrency or tokenized asset, e.g., BTC for Bitcoin.
     * @type {string}
     * @memberof Send2
     */
    'symbol': string;
    /**
     * The amount of each cryptocurrency or tokenized asset in Satoshis. Satoshi figures are in whole numbers.
     * @type {number}
     * @memberof Send2
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface SwapTxId
 */
export interface SwapTxId {
    /**
     * 
     * @type {string}
     * @memberof SwapTxId
     */
    'tx_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SwapTxId
     */
    'tx_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof SwapTxId
     */
    'status'?: SwapTxIdStatusEnum;
}

export const SwapTxIdStatusEnum = {
    New: 'new',
    Existing: 'existing'
} as const;

export type SwapTxIdStatusEnum = typeof SwapTxIdStatusEnum[keyof typeof SwapTxIdStatusEnum];

/**
 * 
 * @export
 * @interface Sweep
 */
export interface Sweep {
    /**
     * 
     * @type {string}
     * @memberof Sweep
     */
    'wallet_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sweep
     */
    'recipient_wallet_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sweep
     */
    'reference'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sweep
     */
    'partner_txID'?: string;
    /**
     * The time in Epoch when the withdrawal will expire if it doesn\'t get approved by the custodians.
     * @type {string}
     * @memberof Sweep
     */
    'expires'?: string;
    /**
     * 
     * @type {Send1}
     * @memberof Sweep
     */
    'send'?: Send1;
}
/**
 * Details of a sweep status
 * @export
 * @interface SweepInfo
 */
export interface SweepInfo {
    /**
     * 
     * @type {number}
     * @memberof SweepInfo
     */
    'approver_count'?: number;
    /**
     * The time in which the transaction expires. The time is in Epoch.
     * @type {number}
     * @memberof SweepInfo
     */
    'expires'?: number;
    /**
     * The time in which the transaction was initiated in Epoch.
     * @type {number}
     * @memberof SweepInfo
     */
    'initiated_timestamp'?: number;
    /**
     * The sweep reference.
     * @type {string}
     * @memberof SweepInfo
     */
    'reference'?: string;
    /**
     * Details of the sweep approval status.
     * @type {Array<SweepInfoStatusInner>}
     * @memberof SweepInfo
     */
    'status'?: Array<SweepInfoStatusInner>;
    /**
     * 
     * @type {SweepInfoStatusDetails}
     * @memberof SweepInfo
     */
    'status_details'?: SweepInfoStatusDetails;
    /**
     * Number of custodian signatures needed for a withdrawal to be approved.
     * @type {number}
     * @memberof SweepInfo
     */
    'threshold_required'?: number;
    /**
     * The transaction ID.
     * @type {string}
     * @memberof SweepInfo
     */
    'tx_id'?: string;
    /**
     * The status of the sweep
     * @type {string}
     * @memberof SweepInfo
     */
    'tx_status'?: string;
}
/**
 * Details of the sweep.
 * @export
 * @interface SweepInfoStatusDetails
 */
export interface SweepInfoStatusDetails {
    /**
     * Amount of the withdrawal in Satoshis (in whole number form).
     * @type {number}
     * @memberof SweepInfoStatusDetails
     */
    'amount'?: number;
    /**
     * Asset of the withdrawal.
     * @type {string}
     * @memberof SweepInfoStatusDetails
     */
    'asset'?: string;
    /**
     * Expiration time
     * @type {number}
     * @memberof SweepInfoStatusDetails
     */
    'expires'?: number;
    /**
     * Amount of the fees in Satoshis.
     * @type {number}
     * @memberof SweepInfoStatusDetails
     */
    'fees'?: number;
    /**
     * The wallet id.
     * @type {string}
     * @memberof SweepInfoStatusDetails
     */
    'wallet_id'?: string;
    /**
     * Amount of the withdrawal after the fees are deducted.
     * @type {number}
     * @memberof SweepInfoStatusDetails
     */
    'net_amount'?: number;
    /**
     * Wallet address of the recipient.
     * @type {string}
     * @memberof SweepInfoStatusDetails
     */
    'recipient_wallet_id'?: string;
    /**
     * Reference sweep.
     * @type {string}
     * @memberof SweepInfoStatusDetails
     */
    'reference'?: string;
    /**
     * The company that requested the withdrawal.
     * @type {string}
     * @memberof SweepInfoStatusDetails
     */
    'requested_by'?: string;
}
/**
 * 
 * @export
 * @interface SweepInfoStatusInner
 */
export interface SweepInfoStatusInner {
    /**
     * The ID assigned to the approval action.
     * @type {string}
     * @memberof SweepInfoStatusInner
     */
    'action_id'?: string;
    /**
     * Custodian status of the sweep as pending, approved, rejected or expired.
     * @type {string}
     * @memberof SweepInfoStatusInner
     */
    'status'?: string;
    /**
     * The time in which the withdrawal was approved or rejected in Epoch.
     * @type {number}
     * @memberof SweepInfoStatusInner
     */
    'timestamp'?: number;
    /**
     * The trade initiator is yet to authorise the transfer.
     * @type {string}
     * @memberof SweepInfoStatusInner
     */
    'entity'?: string;
}
/**
 * 
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'wallet_id': string;
    /**
     * Short code or wallet ID of the recipient wallet of the transaction.
     * @type {string}
     * @memberof Transfer
     */
    'counterparty_wallet_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'reference'?: string;
    /**
     * The recipient of the transaction.
     * @type {string}
     * @memberof Transfer
     */
    'benefit_of'?: string;
    /**
     * Account_no of the recipient of the transaction.
     * @type {string}
     * @memberof Transfer
     */
    'account_no'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'partner_txID'?: string;
    /**
     * Set the CoreClient ID that should authorize the transaction before custodians
     * @type {string}
     * @memberof Transfer
     */
    'authorize_id'?: string;
    /**
     * The time in Epoch when the transfer will expire if it doesn\'t get approved by the custodians.
     * @type {string}
     * @memberof Transfer
     */
    'expires': string;
    /**
     * 
     * @type {Send}
     * @memberof Transfer
     */
    'send'?: Send;
}
/**
 * 
 * @export
 * @interface TrustedParty
 */
export interface TrustedParty {
    /**
     * 
     * @type {string}
     * @memberof TrustedParty
     */
    'company_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof TrustedParty
     */
    'total_count'?: number;
    /**
     * 
     * @type {TrustedPartyList}
     * @memberof TrustedParty
     */
    'list'?: TrustedPartyList;
}
/**
 * 
 * @export
 * @interface TrustedPartyList
 */
export interface TrustedPartyList {
    /**
     * 
     * @type {string}
     * @memberof TrustedPartyList
     */
    'trusted_entity_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrustedPartyList
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrustedPartyList
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrustedPartyList
     */
    'type'?: string;
    /**
     * Timestamp of when the trusted party was created in Epoch time.
     * @type {number}
     * @memberof TrustedPartyList
     */
    'created'?: number;
}
/**
 * 
 * @export
 * @interface TrustedPartyNew
 */
export interface TrustedPartyNew {
    /**
     * Email address of the user.
     * @type {string}
     * @memberof TrustedPartyNew
     */
    'address': string;
}
/**
 * TxHistoryItem is a single record of a transaction history
 * @export
 * @interface TxHistoryItem
 */
export interface TxHistoryItem {
    /**
     * 
     * @type {string}
     * @memberof TxHistoryItem
     */
    'TxID'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxHistoryItem
     */
    'accountNo'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxHistoryItem
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof TxHistoryItem
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TxHistoryItem
     */
    'asset'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxHistoryItem
     */
    'benefitOf'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxHistoryItem
     */
    'chainTxID'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxHistoryItem
     */
    'counterpartyID'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxHistoryItem
     */
    'counterpartyName'?: string;
    /**
     * 
     * @type {number}
     * @memberof TxHistoryItem
     */
    'expireTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof TxHistoryItem
     */
    'fees'?: number;
    /**
     * 
     * @type {string}
     * @memberof TxHistoryItem
     */
    'fundID'?: string;
    /**
     * 
     * @type {number}
     * @memberof TxHistoryItem
     */
    'netAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TxHistoryItem
     */
    'reference'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxHistoryItem
     */
    'status'?: TxHistoryItemStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof TxHistoryItem
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof TxHistoryItem
     */
    'type'?: TxHistoryItemTypeEnum;
}

export const TxHistoryItemStatusEnum = {
    PendingInitiate: 'pending_initiate',
    Pending: 'pending',
    Expired: 'expired',
    Approved: 'approved',
    InitiateRejected: 'initiate_rejected',
    CustodyRejected: 'custody_rejected',
    ChainRejected: 'chain_rejected',
    TakerPending: 'taker_pending',
    TakerApproved: 'taker_approved'
} as const;

export type TxHistoryItemStatusEnum = typeof TxHistoryItemStatusEnum[keyof typeof TxHistoryItemStatusEnum];
export const TxHistoryItemTypeEnum = {
    None: 'none',
    Deposit: 'deposit',
    Withdraw: 'withdraw',
    TransferIn: 'transferIn',
    TransferOut: 'transferOut',
    Swap: 'swap',
    SwapIn: 'swapIn',
    SwapOut: 'swapOut'
} as const;

export type TxHistoryItemTypeEnum = typeof TxHistoryItemTypeEnum[keyof typeof TxHistoryItemTypeEnum];

/**
 * 
 * @export
 * @interface TxId
 */
export interface TxId {
    /**
     * 
     * @type {string}
     * @memberof TxId
     */
    'tx_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxId
     */
    'status'?: TxIdStatusEnum;
}

export const TxIdStatusEnum = {
    New: 'new',
    Existing: 'existing'
} as const;

export type TxIdStatusEnum = typeof TxIdStatusEnum[keyof typeof TxIdStatusEnum];

/**
 * Details of a specific transfer.
 * @export
 * @interface TxInfo
 */
export interface TxInfo {
    /**
     * The approvedCount is the number of custodians that have approved the transfer. When it reaches the threshold, the transaction goes through and the Qredo Blockchain is updated. If less than the threshold, the transaction does not go through.
     * @type {number}
     * @memberof TxInfo
     */
    'approver_count'?: number;
    /**
     * The time in which the transaction expires where custodian approvals are needed. The time is in Epoch.
     * @type {number}
     * @memberof TxInfo
     */
    'expires'?: number;
    /**
     * The time in which the transaction was initiated in Epoch.
     * @type {number}
     * @memberof TxInfo
     */
    'initiated_timestamp'?: number;
    /**
     * Status to indicate if the transaction is authorised by the trade initiator.                      True indicates that the transaction is authorised and False indicates that                      the transaction is not yet authorised. All transactions need to be authorised                      by the initiator.
     * @type {boolean}
     * @memberof TxInfo
     */
    'initiator_authorized'?: boolean;
    /**
     * Name of the trade initiator that initiated the transfer.
     * @type {string}
     * @memberof TxInfo
     */
    'initiator_name'?: string;
    /**
     * The transfer reference number.
     * @type {string}
     * @memberof TxInfo
     */
    'reference'?: string;
    /**
     * Details of the transfer approval status.
     * @type {Array<TxInfoStatusInner>}
     * @memberof TxInfo
     */
    'status'?: Array<TxInfoStatusInner>;
    /**
     * 
     * @type {TxInfoStatusDetails}
     * @memberof TxInfo
     */
    'status_details'?: TxInfoStatusDetails;
    /**
     * Number of custodian signatures needed for a transfer to be approved.
     * @type {number}
     * @memberof TxInfo
     */
    'threshold_required'?: number;
    /**
     * The transaction ID.
     * @type {string}
     * @memberof TxInfo
     */
    'tx_id'?: string;
    /**
     * 
     * @type {TxInfoTxStatus}
     * @memberof TxInfo
     */
    'tx_status'?: TxInfoTxStatus;
}
/**
 * Details of the transfer status.
 * @export
 * @interface TxInfoStatusDetails
 */
export interface TxInfoStatusDetails {
    /**
     * Account number of the counterparty
     * @type {string}
     * @memberof TxInfoStatusDetails
     */
    'account_no'?: string;
    /**
     * Amount of the transfer in Satoshis (in whole number form).
     * @type {number}
     * @memberof TxInfoStatusDetails
     */
    'amount'?: number;
    /**
     * Asset of the transfer.
     * @type {string}
     * @memberof TxInfoStatusDetails
     */
    'asset'?: string;
    /**
     * Beneficiary of the transfer.
     * @type {string}
     * @memberof TxInfoStatusDetails
     */
    'benefit_of'?: string;
    /**
     * Expiration time
     * @type {number}
     * @memberof TxInfoStatusDetails
     */
    'expires'?: number;
    /**
     * Amount of the fees in Satoshis.
     * @type {number}
     * @memberof TxInfoStatusDetails
     */
    'fees'?: number;
    /**
     * fund ID of the transfer.
     * @type {string}
     * @memberof TxInfoStatusDetails
     */
    'fund_id'?: string;
    /**
     * Amount of the transfer after the fees are deducted.
     * @type {number}
     * @memberof TxInfoStatusDetails
     */
    'net_amount'?: number;
    /**
     * Wallet address of the recipient.
     * @type {string}
     * @memberof TxInfoStatusDetails
     */
    'recipient_address'?: string;
    /**
     * Email address of the receiving counterparty.
     * @type {string}
     * @memberof TxInfoStatusDetails
     */
    'recipient_email'?: string;
    /**
     * First name of the receiving counterparty.
     * @type {string}
     * @memberof TxInfoStatusDetails
     */
    'recipient_first_name'?: string;
    /**
     * Last name of the receiving counterparty.
     * @type {string}
     * @memberof TxInfoStatusDetails
     */
    'recipient_last_name'?: string;
    /**
     * User name of the receiving counterparty.
     * @type {string}
     * @memberof TxInfoStatusDetails
     */
    'recipient_username'?: string;
    /**
     * Reference number of the transfer.
     * @type {string}
     * @memberof TxInfoStatusDetails
     */
    'reference'?: string;
    /**
     * The company that requested the transfer.
     * @type {string}
     * @memberof TxInfoStatusDetails
     */
    'requested_by'?: string;
}
/**
 * 
 * @export
 * @interface TxInfoStatusInner
 */
export interface TxInfoStatusInner {
    /**
     * The ID assigned to the approval action.
     * @type {string}
     * @memberof TxInfoStatusInner
     */
    'action_id'?: string;
    /**
     * First name of the custodian.
     * @type {string}
     * @memberof TxInfoStatusInner
     */
    'first_name'?: string;
    /**
     * Last name of the custodian.
     * @type {string}
     * @memberof TxInfoStatusInner
     */
    'last_name'?: string;
    /**
     * Custodian status of the transfer as pending, approved, rejected or expired.
     * @type {string}
     * @memberof TxInfoStatusInner
     */
    'status'?: string;
    /**
     * The time in which the transfer was approved or rejected in Epoch.
     * @type {number}
     * @memberof TxInfoStatusInner
     */
    'timestamp'?: number;
    /**
     * User ID of the custodian.
     * @type {string}
     * @memberof TxInfoStatusInner
     */
    'user_id'?: string;
    /**
     * User name of the custodian.
     * @type {string}
     * @memberof TxInfoStatusInner
     */
    'username'?: string;
}
/**
 * @type TxInfoTxStatus
 * The status of the transfer
 * @export
 */
export type TxInfoTxStatus = string;

/**
 * Transaction ledger
 * @export
 * @interface TxLedger
 */
export interface TxLedger {
    /**
     * 
     * @type {Array<TxHistoryItem>}
     * @memberof TxLedger
     */
    'List'?: Array<TxHistoryItem>;
    /**
     * 
     * @type {number}
     * @memberof TxLedger
     */
    'Total'?: number;
}
/**
 * 
 * @export
 * @interface UpdateWalletPolicyRequest
 */
export interface UpdateWalletPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateWalletPolicyRequest
     */
    'policy_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateWalletPolicyRequest
     */
    'threshold'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateWalletPolicyRequest
     */
    'members'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateWalletPolicyRequest
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * User ID
     * @type {string}
     * @memberof User
     */
    'user_id': string;
    /**
     * User first name.
     * @type {string}
     * @memberof User
     */
    'firstName': string;
    /**
     * User last name.
     * @type {string}
     * @memberof User
     */
    'lastName': string;
    /**
     * User email address.
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * User mobile number address.
     * @type {string}
     * @memberof User
     */
    'phone': string;
    /**
     * This declares whether a user is an admin or not. Users with admin privileges can create trading spaces.
     * @type {boolean}
     * @memberof User
     */
    'space_admin': boolean;
    /**
     * User Status will note the stage at which each end user is during the signup process. Example, 0 is not invited, 1 sends an invite, etc.
     * @type {number}
     * @memberof User
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface UserList
 */
export interface UserList {
    /**
     * The company id.
     * @type {string}
     * @memberof UserList
     */
    'company_id': string;
    /**
     * The total number of users.
     * @type {number}
     * @memberof UserList
     */
    'total_count': number;
    /**
     * 
     * @type {Array<ListInner3>}
     * @memberof UserList
     */
    'list': Array<ListInner3>;
}
/**
 * 
 * @export
 * @interface UserNewList
 */
export interface UserNewList {
    /**
     * 
     * @type {Array<InviteUser>}
     * @memberof UserNewList
     */
    'list': Array<InviteUser>;
}
/**
 * 
 * @export
 * @interface UserNewListResponse
 */
export interface UserNewListResponse {
    /**
     * 
     * @type {Array<UserNewResponse>}
     * @memberof UserNewListResponse
     */
    'created': Array<UserNewResponse>;
}
/**
 * 
 * @export
 * @interface UserNewResponse
 */
export interface UserNewResponse {
    /**
     * User email
     * @type {string}
     * @memberof UserNewResponse
     */
    'email'?: string;
    /**
     * User ID
     * @type {string}
     * @memberof UserNewResponse
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * This declares whether a user is an admin or not. Users with admin privileges can create trading spaces.
     * @type {number}
     * @memberof UserUpdate
     */
    'space_admin': number;
}
/**
 * 
 * @export
 * @interface WalletIDList
 */
export interface WalletIDList {
    /**
     * 
     * @type {Array<string>}
     * @memberof WalletIDList
     */
    'wallets'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Withdrawal
 */
export interface Withdrawal {
    /**
     * 
     * @type {string}
     * @memberof Withdrawal
     */
    'wallet_id': string;
    /**
     * The withdrawal address
     * @type {string}
     * @memberof Withdrawal
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof Withdrawal
     */
    'reference'?: string;
    /**
     * 
     * @type {string}
     * @memberof Withdrawal
     */
    'benefit_of'?: string;
    /**
     * 
     * @type {string}
     * @memberof Withdrawal
     */
    'account_no'?: string;
    /**
     * 
     * @type {string}
     * @memberof Withdrawal
     */
    'partner_txID'?: string;
    /**
     * The time in Epoch when the withdrawal will expire if it doesn\'t get approved by the custodians.
     * @type {string}
     * @memberof Withdrawal
     */
    'expires': string;
    /**
     * 
     * @type {Send1}
     * @memberof Withdrawal
     */
    'send'?: Send1;
}
/**
 * Details of a withdrawal status
 * @export
 * @interface WithdrawalInfo
 */
export interface WithdrawalInfo {
    /**
     * The approvedCount is the number of custodians that have approved the withdrawal. When it reaches the threshold, the transaction goes through and the Qredo Blockchain is updated. If less than the threshold, the transaction does not go through.
     * @type {number}
     * @memberof WithdrawalInfo
     */
    'approver_count'?: number;
    /**
     * The time in which the transaction expires where custodian approvals are needed. The time is in Epoch.
     * @type {number}
     * @memberof WithdrawalInfo
     */
    'expires'?: number;
    /**
     * The time in which the transaction was initiated in Epoch.
     * @type {number}
     * @memberof WithdrawalInfo
     */
    'initiated_timestamp'?: number;
    /**
     * Status to indicate if the withdrawal is authorised by the trade initiator.                      True indicates that the withdrawal is authorised and False indicates that                      the withdrawal is not yet authorised. All transactions need to be authorised                      by the initiator.
     * @type {boolean}
     * @memberof WithdrawalInfo
     */
    'initiator_authorized'?: boolean;
    /**
     * Name of the trade initiator that initiated the withdrawal.
     * @type {string}
     * @memberof WithdrawalInfo
     */
    'initiator_name'?: string;
    /**
     * The withdrawal reference number.
     * @type {string}
     * @memberof WithdrawalInfo
     */
    'reference'?: string;
    /**
     * Details of the withdrawal approval status.
     * @type {Array<WithdrawalInfoStatusInner>}
     * @memberof WithdrawalInfo
     */
    'status'?: Array<WithdrawalInfoStatusInner>;
    /**
     * 
     * @type {WithdrawalInfoStatusDetails}
     * @memberof WithdrawalInfo
     */
    'status_details'?: WithdrawalInfoStatusDetails;
    /**
     * Number of custodian signatures needed for a withdrawal to be approved.
     * @type {number}
     * @memberof WithdrawalInfo
     */
    'threshold_required'?: number;
    /**
     * The transaction ID.
     * @type {string}
     * @memberof WithdrawalInfo
     */
    'tx_id'?: string;
    /**
     * 
     * @type {WithdrawalInfoTxStatus}
     * @memberof WithdrawalInfo
     */
    'tx_status'?: WithdrawalInfoTxStatus;
}
/**
 * Details of the withdrawal status.
 * @export
 * @interface WithdrawalInfoStatusDetails
 */
export interface WithdrawalInfoStatusDetails {
    /**
     * Account number of the counterparty
     * @type {string}
     * @memberof WithdrawalInfoStatusDetails
     */
    'account_no'?: string;
    /**
     * Amount of the withdrawal in Satoshis (in whole number form).
     * @type {number}
     * @memberof WithdrawalInfoStatusDetails
     */
    'amount'?: number;
    /**
     * Asset of the withdrawal.
     * @type {string}
     * @memberof WithdrawalInfoStatusDetails
     */
    'asset'?: string;
    /**
     * Beneficiary of the withdrawal.
     * @type {string}
     * @memberof WithdrawalInfoStatusDetails
     */
    'benefit_of'?: string;
    /**
     * Expiration time
     * @type {number}
     * @memberof WithdrawalInfoStatusDetails
     */
    'expires'?: number;
    /**
     * Amount of the fees in Satoshis.
     * @type {number}
     * @memberof WithdrawalInfoStatusDetails
     */
    'fees'?: number;
    /**
     * fund ID of the withdrawal.
     * @type {string}
     * @memberof WithdrawalInfoStatusDetails
     */
    'fund_id'?: string;
    /**
     * Amount of the withdrawal after the fees are deducted.
     * @type {number}
     * @memberof WithdrawalInfoStatusDetails
     */
    'net_amount'?: number;
    /**
     * Wallet address of the recipient.
     * @type {string}
     * @memberof WithdrawalInfoStatusDetails
     */
    'recipient_address'?: string;
    /**
     * Email address of the receiving counterparty.
     * @type {string}
     * @memberof WithdrawalInfoStatusDetails
     */
    'recipient_email'?: string;
    /**
     * First name of the receiving counterparty.
     * @type {string}
     * @memberof WithdrawalInfoStatusDetails
     */
    'recipient_first_name'?: string;
    /**
     * Last name of the receiving counterparty.
     * @type {string}
     * @memberof WithdrawalInfoStatusDetails
     */
    'recipient_last_name'?: string;
    /**
     * User name of the receiving counterparty.
     * @type {string}
     * @memberof WithdrawalInfoStatusDetails
     */
    'recipient_username'?: string;
    /**
     * Reference number of the withdrawal.
     * @type {string}
     * @memberof WithdrawalInfoStatusDetails
     */
    'reference'?: string;
    /**
     * The company that requested the withdrawal.
     * @type {string}
     * @memberof WithdrawalInfoStatusDetails
     */
    'requested_by'?: string;
}
/**
 * 
 * @export
 * @interface WithdrawalInfoStatusInner
 */
export interface WithdrawalInfoStatusInner {
    /**
     * The ID assigned to the approval action.
     * @type {string}
     * @memberof WithdrawalInfoStatusInner
     */
    'action_id'?: string;
    /**
     * First name of the custodian.
     * @type {string}
     * @memberof WithdrawalInfoStatusInner
     */
    'first_name'?: string;
    /**
     * Last name of the custodian.
     * @type {string}
     * @memberof WithdrawalInfoStatusInner
     */
    'last_name'?: string;
    /**
     * Custodian status of the withdrawal as pending, approved, rejected or expired.
     * @type {string}
     * @memberof WithdrawalInfoStatusInner
     */
    'status'?: string;
    /**
     * The time in which the withdrawal was approved or rejected in Epoch.
     * @type {number}
     * @memberof WithdrawalInfoStatusInner
     */
    'timestamp'?: number;
    /**
     * User ID of the custodian.
     * @type {string}
     * @memberof WithdrawalInfoStatusInner
     */
    'user_id'?: string;
    /**
     * User name of the custodian.
     * @type {string}
     * @memberof WithdrawalInfoStatusInner
     */
    'username'?: string;
}
/**
 * @type WithdrawalInfoTxStatus
 * The status of the withdrawal
 * @export
 */
export type WithdrawalInfoTxStatus = string;


/**
 * AtomicSwapApi - axios parameter creator
 * @export
 */
export const AtomicSwapApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiate an Atomic Swap Quote and set parameters for the transaction.
         * @summary Create Atomic Swap Quote
         * @param {string} companyId 
         * @param {AtomicSwapMake} atomicSwapMake 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakePost: async (companyId: string, atomicSwapMake: AtomicSwapMake, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdAtomicswapMakePost', 'companyId', companyId)
            // verify required parameter 'atomicSwapMake' is not null or undefined
            assertParamExists('companyCompanyIdAtomicswapMakePost', 'atomicSwapMake', atomicSwapMake)
            const localVarPath = `/company/{company_id}/atomicswap/make`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(atomicSwapMake, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel atomic swap
         * @summary Cancel Atomic Swap
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakeTxIdDelete: async (companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdAtomicswapMakeTxIdDelete', 'companyId', companyId)
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('companyCompanyIdAtomicswapMakeTxIdDelete', 'txId', txId)
            const localVarPath = `/company/{company_id}/atomicswap/make/{tx_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain details on an atomic swap
         * @summary Get Atomic Swaps Quote details
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakeTxIdGet: async (companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdAtomicswapMakeTxIdGet', 'companyId', companyId)
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('companyCompanyIdAtomicswapMakeTxIdGet', 'txId', txId)
            const localVarPath = `/company/{company_id}/atomicswap/make/{tx_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate an atomic swap take transaction.
         * @summary Initiate Atomic swap taker transaction
         * @param {string} companyId 
         * @param {AtomicSwapTake} atomicSwapTake 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapTakePost: async (companyId: string, atomicSwapTake: AtomicSwapTake, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdAtomicswapTakePost', 'companyId', companyId)
            // verify required parameter 'atomicSwapTake' is not null or undefined
            assertParamExists('companyCompanyIdAtomicswapTakePost', 'atomicSwapTake', atomicSwapTake)
            const localVarPath = `/company/{company_id}/atomicswap/take`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(atomicSwapTake, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain details on an atomic swap
         * @summary Get atomic swap taker status
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapTakeTxIdGet: async (companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdAtomicswapTakeTxIdGet', 'companyId', companyId)
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('companyCompanyIdAtomicswapTakeTxIdGet', 'txId', txId)
            const localVarPath = `/company/{company_id}/atomicswap/take/{tx_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtomicSwapApi - functional programming interface
 * @export
 */
export const AtomicSwapApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AtomicSwapApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiate an Atomic Swap Quote and set parameters for the transaction.
         * @summary Create Atomic Swap Quote
         * @param {string} companyId 
         * @param {AtomicSwapMake} atomicSwapMake 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdAtomicswapMakePost(companyId: string, atomicSwapMake: AtomicSwapMake, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SwapTxId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdAtomicswapMakePost(companyId, atomicSwapMake, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel atomic swap
         * @summary Cancel Atomic Swap
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdAtomicswapMakeTxIdDelete(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdAtomicswapMakeTxIdDelete(companyId, txId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Obtain details on an atomic swap
         * @summary Get Atomic Swaps Quote details
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdAtomicswapMakeTxIdGet(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdAtomicswapMakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiate an atomic swap take transaction.
         * @summary Initiate Atomic swap taker transaction
         * @param {string} companyId 
         * @param {AtomicSwapTake} atomicSwapTake 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdAtomicswapTakePost(companyId: string, atomicSwapTake: AtomicSwapTake, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdAtomicswapTakePost(companyId, atomicSwapTake, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Obtain details on an atomic swap
         * @summary Get atomic swap taker status
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdAtomicswapTakeTxIdGet(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdAtomicswapTakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AtomicSwapApi - factory interface
 * @export
 */
export const AtomicSwapApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AtomicSwapApiFp(configuration)
    return {
        /**
         * Initiate an Atomic Swap Quote and set parameters for the transaction.
         * @summary Create Atomic Swap Quote
         * @param {string} companyId 
         * @param {AtomicSwapMake} atomicSwapMake 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakePost(companyId: string, atomicSwapMake: AtomicSwapMake, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<SwapTxId> {
            return localVarFp.companyCompanyIdAtomicswapMakePost(companyId, atomicSwapMake, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel atomic swap
         * @summary Cancel Atomic Swap
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakeTxIdDelete(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<OkResponse> {
            return localVarFp.companyCompanyIdAtomicswapMakeTxIdDelete(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain details on an atomic swap
         * @summary Get Atomic Swaps Quote details
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapMakeTxIdGet(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<void> {
            return localVarFp.companyCompanyIdAtomicswapMakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate an atomic swap take transaction.
         * @summary Initiate Atomic swap taker transaction
         * @param {string} companyId 
         * @param {AtomicSwapTake} atomicSwapTake 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapTakePost(companyId: string, atomicSwapTake: AtomicSwapTake, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<TxId> {
            return localVarFp.companyCompanyIdAtomicswapTakePost(companyId, atomicSwapTake, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain details on an atomic swap
         * @summary Get atomic swap taker status
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdAtomicswapTakeTxIdGet(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<void> {
            return localVarFp.companyCompanyIdAtomicswapTakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AtomicSwapApi - object-oriented interface
 * @export
 * @class AtomicSwapApi
 * @extends {BaseAPI}
 */
export class AtomicSwapApi extends BaseAPI {
    /**
     * Initiate an Atomic Swap Quote and set parameters for the transaction.
     * @summary Create Atomic Swap Quote
     * @param {string} companyId 
     * @param {AtomicSwapMake} atomicSwapMake 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicSwapApi
     */
    public companyCompanyIdAtomicswapMakePost(companyId: string, atomicSwapMake: AtomicSwapMake, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return AtomicSwapApiFp(this.configuration).companyCompanyIdAtomicswapMakePost(companyId, atomicSwapMake, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel atomic swap
     * @summary Cancel Atomic Swap
     * @param {string} companyId 
     * @param {string} txId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicSwapApi
     */
    public companyCompanyIdAtomicswapMakeTxIdDelete(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return AtomicSwapApiFp(this.configuration).companyCompanyIdAtomicswapMakeTxIdDelete(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtain details on an atomic swap
     * @summary Get Atomic Swaps Quote details
     * @param {string} companyId 
     * @param {string} txId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicSwapApi
     */
    public companyCompanyIdAtomicswapMakeTxIdGet(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return AtomicSwapApiFp(this.configuration).companyCompanyIdAtomicswapMakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate an atomic swap take transaction.
     * @summary Initiate Atomic swap taker transaction
     * @param {string} companyId 
     * @param {AtomicSwapTake} atomicSwapTake 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicSwapApi
     */
    public companyCompanyIdAtomicswapTakePost(companyId: string, atomicSwapTake: AtomicSwapTake, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return AtomicSwapApiFp(this.configuration).companyCompanyIdAtomicswapTakePost(companyId, atomicSwapTake, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtain details on an atomic swap
     * @summary Get atomic swap taker status
     * @param {string} companyId 
     * @param {string} txId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicSwapApi
     */
    public companyCompanyIdAtomicswapTakeTxIdGet(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return AtomicSwapApiFp(this.configuration).companyCompanyIdAtomicswapTakeTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AutomatedApproverApi - axios parameter creator
 * @export
 */
export const AutomatedApproverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Finishes core client registration by storing the signed IDDoc
         * @summary Finish core client onboarding
         * @param {CoreclientFinishPostRequest} coreclientFinishPostRequest 
         * @param {string} [xApiXkp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientFinishPost: async (coreclientFinishPostRequest: CoreclientFinishPostRequest, xApiXkp?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coreclientFinishPostRequest' is not null or undefined
            assertParamExists('coreclientFinishPost', 'coreclientFinishPostRequest', coreclientFinishPostRequest)
            const localVarPath = `/coreclient/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiXkp != null) {
                localVarHeaderParameter['x-api-xkp'] = String(xApiXkp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(coreclientFinishPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates an automated approver core client registration
         * @summary Initiate core client onboarding
         * @param {Request} request 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientInitPost: async (request: Request, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('coreclientInitPost', 'request', request)
            const localVarPath = `/coreclient/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reject action_id
         * @summary Reject action
         * @param {string} actionId 
         * @param {string} [xApiZkp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoreclientActionActionId: async (actionId: string, xApiZkp?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('deleteCoreclientActionActionId', 'actionId', actionId)
            const localVarPath = `/coreclient/action/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiZkp != null) {
                localVarHeaderParameter['x-api-zkp'] = String(xApiZkp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns action messages for action_id
         * @summary Get action messages
         * @param {string} actionId 
         * @param {string} [xApiZkp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreclientActionActionId: async (actionId: string, xApiZkp?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('getCoreclientActionActionId', 'actionId', actionId)
            const localVarPath = `/coreclient/action/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiZkp != null) {
                localVarHeaderParameter['x-api-zkp'] = String(xApiZkp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * WebSocket feed for core client actions
         * @summary Get core client actions feed
         * @param {string} [xApiZkp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreclientFeed: async (xApiZkp?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coreclient/feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiZkp != null) {
                localVarHeaderParameter['x-api-zkp'] = String(xApiZkp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve acction_id
         * @summary Approve action
         * @param {string} actionId 
         * @param {string} [xApiZkp] 
         * @param {PutCoreclientActionActionIdRequest} [putCoreclientActionActionIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCoreclientActionActionId: async (actionId: string, xApiZkp?: string, putCoreclientActionActionIdRequest?: PutCoreclientActionActionIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('putCoreclientActionActionId', 'actionId', actionId)
            const localVarPath = `/coreclient/action/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiZkp != null) {
                localVarHeaderParameter['x-api-zkp'] = String(xApiZkp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putCoreclientActionActionIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutomatedApproverApi - functional programming interface
 * @export
 */
export const AutomatedApproverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutomatedApproverApiAxiosParamCreator(configuration)
    return {
        /**
         * Finishes core client registration by storing the signed IDDoc
         * @summary Finish core client onboarding
         * @param {CoreclientFinishPostRequest} coreclientFinishPostRequest 
         * @param {string} [xApiXkp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientFinishPost(coreclientFinishPostRequest: CoreclientFinishPostRequest, xApiXkp?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientFinishPost(coreclientFinishPostRequest, xApiXkp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiates an automated approver core client registration
         * @summary Initiate core client onboarding
         * @param {Request} request 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientInitPost(request: Request, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientInitPost(request, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reject action_id
         * @summary Reject action
         * @param {string} actionId 
         * @param {string} [xApiZkp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCoreclientActionActionId(actionId: string, xApiZkp?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCoreclientActionActionId(actionId, xApiZkp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns action messages for action_id
         * @summary Get action messages
         * @param {string} actionId 
         * @param {string} [xApiZkp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoreclientActionActionId(actionId: string, xApiZkp?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCoreclientActionActionId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoreclientActionActionId(actionId, xApiZkp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * WebSocket feed for core client actions
         * @summary Get core client actions feed
         * @param {string} [xApiZkp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoreclientFeed(xApiZkp?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoreclientFeed(xApiZkp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Approve acction_id
         * @summary Approve action
         * @param {string} actionId 
         * @param {string} [xApiZkp] 
         * @param {PutCoreclientActionActionIdRequest} [putCoreclientActionActionIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCoreclientActionActionId(actionId: string, xApiZkp?: string, putCoreclientActionActionIdRequest?: PutCoreclientActionActionIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCoreclientActionActionId(actionId, xApiZkp, putCoreclientActionActionIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutomatedApproverApi - factory interface
 * @export
 */
export const AutomatedApproverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutomatedApproverApiFp(configuration)
    return {
        /**
         * Finishes core client registration by storing the signed IDDoc
         * @summary Finish core client onboarding
         * @param {CoreclientFinishPostRequest} coreclientFinishPostRequest 
         * @param {string} [xApiXkp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientFinishPost(coreclientFinishPostRequest: CoreclientFinishPostRequest, xApiXkp?: string, options?: any): AxiosPromise<void> {
            return localVarFp.coreclientFinishPost(coreclientFinishPostRequest, xApiXkp, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates an automated approver core client registration
         * @summary Initiate core client onboarding
         * @param {Request} request 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientInitPost(request: Request, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<void> {
            return localVarFp.coreclientInitPost(request, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Reject action_id
         * @summary Reject action
         * @param {string} actionId 
         * @param {string} [xApiZkp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoreclientActionActionId(actionId: string, xApiZkp?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCoreclientActionActionId(actionId, xApiZkp, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns action messages for action_id
         * @summary Get action messages
         * @param {string} actionId 
         * @param {string} [xApiZkp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreclientActionActionId(actionId: string, xApiZkp?: string, options?: any): AxiosPromise<GetCoreclientActionActionId200Response> {
            return localVarFp.getCoreclientActionActionId(actionId, xApiZkp, options).then((request) => request(axios, basePath));
        },
        /**
         * WebSocket feed for core client actions
         * @summary Get core client actions feed
         * @param {string} [xApiZkp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreclientFeed(xApiZkp?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getCoreclientFeed(xApiZkp, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve acction_id
         * @summary Approve action
         * @param {string} actionId 
         * @param {string} [xApiZkp] 
         * @param {PutCoreclientActionActionIdRequest} [putCoreclientActionActionIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCoreclientActionActionId(actionId: string, xApiZkp?: string, putCoreclientActionActionIdRequest?: PutCoreclientActionActionIdRequest, options?: any): AxiosPromise<void> {
            return localVarFp.putCoreclientActionActionId(actionId, xApiZkp, putCoreclientActionActionIdRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutomatedApproverApi - object-oriented interface
 * @export
 * @class AutomatedApproverApi
 * @extends {BaseAPI}
 */
export class AutomatedApproverApi extends BaseAPI {
    /**
     * Finishes core client registration by storing the signed IDDoc
     * @summary Finish core client onboarding
     * @param {CoreclientFinishPostRequest} coreclientFinishPostRequest 
     * @param {string} [xApiXkp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomatedApproverApi
     */
    public coreclientFinishPost(coreclientFinishPostRequest: CoreclientFinishPostRequest, xApiXkp?: string, options?: AxiosRequestConfig) {
        return AutomatedApproverApiFp(this.configuration).coreclientFinishPost(coreclientFinishPostRequest, xApiXkp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates an automated approver core client registration
     * @summary Initiate core client onboarding
     * @param {Request} request 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomatedApproverApi
     */
    public coreclientInitPost(request: Request, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return AutomatedApproverApiFp(this.configuration).coreclientInitPost(request, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reject action_id
     * @summary Reject action
     * @param {string} actionId 
     * @param {string} [xApiZkp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomatedApproverApi
     */
    public deleteCoreclientActionActionId(actionId: string, xApiZkp?: string, options?: AxiosRequestConfig) {
        return AutomatedApproverApiFp(this.configuration).deleteCoreclientActionActionId(actionId, xApiZkp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns action messages for action_id
     * @summary Get action messages
     * @param {string} actionId 
     * @param {string} [xApiZkp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomatedApproverApi
     */
    public getCoreclientActionActionId(actionId: string, xApiZkp?: string, options?: AxiosRequestConfig) {
        return AutomatedApproverApiFp(this.configuration).getCoreclientActionActionId(actionId, xApiZkp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * WebSocket feed for core client actions
     * @summary Get core client actions feed
     * @param {string} [xApiZkp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomatedApproverApi
     */
    public getCoreclientFeed(xApiZkp?: string, options?: AxiosRequestConfig) {
        return AutomatedApproverApiFp(this.configuration).getCoreclientFeed(xApiZkp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approve acction_id
     * @summary Approve action
     * @param {string} actionId 
     * @param {string} [xApiZkp] 
     * @param {PutCoreclientActionActionIdRequest} [putCoreclientActionActionIdRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomatedApproverApi
     */
    public putCoreclientActionActionId(actionId: string, xApiZkp?: string, putCoreclientActionActionIdRequest?: PutCoreclientActionActionIdRequest, options?: AxiosRequestConfig) {
        return AutomatedApproverApiFp(this.configuration).putCoreclientActionActionId(actionId, xApiZkp, putCoreclientActionActionIdRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommonApi - axios parameter creator
 * @export
 */
export const CommonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * returns a list of supported assets and their codes
         * @summary Supported assets
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsGet: async (xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculate fees for specific assets and transaction types for any company on the network.
         * @summary Calculate fees
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {FeesRequest} [feesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesPost: async (xNonce?: string, xTimestamp?: string, xSign?: string, feesRequest?: FeesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommonApi - functional programming interface
 * @export
 */
export const CommonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommonApiAxiosParamCreator(configuration)
    return {
        /**
         * returns a list of supported assets and their codes
         * @summary Supported assets
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetsGet(xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetsGet(xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Calculate fees for specific assets and transaction types for any company on the network.
         * @summary Calculate fees
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {FeesRequest} [feesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feesPost(xNonce?: string, xTimestamp?: string, xSign?: string, feesRequest?: FeesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feesPost(xNonce, xTimestamp, xSign, feesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommonApi - factory interface
 * @export
 */
export const CommonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommonApiFp(configuration)
    return {
        /**
         * returns a list of supported assets and their codes
         * @summary Supported assets
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsGet(xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<Assets> {
            return localVarFp.assetsGet(xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculate fees for specific assets and transaction types for any company on the network.
         * @summary Calculate fees
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {FeesRequest} [feesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesPost(xNonce?: string, xTimestamp?: string, xSign?: string, feesRequest?: FeesRequest, options?: any): AxiosPromise<FeesResponse> {
            return localVarFp.feesPost(xNonce, xTimestamp, xSign, feesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommonApi - object-oriented interface
 * @export
 * @class CommonApi
 * @extends {BaseAPI}
 */
export class CommonApi extends BaseAPI {
    /**
     * returns a list of supported assets and their codes
     * @summary Supported assets
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonApi
     */
    public assetsGet(xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return CommonApiFp(this.configuration).assetsGet(xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculate fees for specific assets and transaction types for any company on the network.
     * @summary Calculate fees
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {FeesRequest} [feesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonApi
     */
    public feesPost(xNonce?: string, xTimestamp?: string, xSign?: string, feesRequest?: FeesRequest, options?: AxiosRequestConfig) {
        return CommonApiFp(this.configuration).feesPost(xNonce, xTimestamp, xSign, feesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CompanyApi - axios parameter creator
 * @export
 */
export const CompanyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * returns details of a Company from the Company ID.
         * @summary Get Company
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdGet: async (companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdGet', 'companyId', companyId)
            const localVarPath = `/company/{company_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change details of a Company
         * @summary Update Company
         * @param {string} companyId 
         * @param {Company} company 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdPut: async (companyId: string, company: Company, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdPut', 'companyId', companyId)
            // verify required parameter 'company' is not null or undefined
            assertParamExists('companyCompanyIdPut', 'company', company)
            const localVarPath = `/company/{company_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(company, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Company on behalf of a customer account to include all managed network entities  i.e. Trusted Parties, Holdings, Funds, Custody Policies and those for the movement of assets (deposits, transfers, and withdrawals).
         * @summary Create Company
         * @param {Company} company 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyPost: async (company: Company, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'company' is not null or undefined
            assertParamExists('companyPost', 'company', company)
            const localVarPath = `/company`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(company, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for a Company in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all companies where those letters exist.
         * @summary Search Company
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companySearchGet: async (xNonce?: string, xTimestamp?: string, xSign?: string, query?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/company/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyApi - functional programming interface
 * @export
 */
export const CompanyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompanyApiAxiosParamCreator(configuration)
    return {
        /**
         * returns details of a Company from the Company ID.
         * @summary Get Company
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdGet(companyId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change details of a Company
         * @summary Update Company
         * @param {string} companyId 
         * @param {Company} company 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdPut(companyId: string, company: Company, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCompanyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdPut(companyId, company, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Company on behalf of a customer account to include all managed network entities  i.e. Trusted Parties, Holdings, Funds, Custody Policies and those for the movement of assets (deposits, transfers, and withdrawals).
         * @summary Create Company
         * @param {Company} company 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyPost(company: Company, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCompanyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyPost(company, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search for a Company in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all companies where those letters exist.
         * @summary Search Company
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companySearchGet(xNonce?: string, xTimestamp?: string, xSign?: string, query?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanySearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companySearchGet(xNonce, xTimestamp, xSign, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CompanyApi - factory interface
 * @export
 */
export const CompanyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompanyApiFp(configuration)
    return {
        /**
         * returns details of a Company from the Company ID.
         * @summary Get Company
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<Company> {
            return localVarFp.companyCompanyIdGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Change details of a Company
         * @summary Update Company
         * @param {string} companyId 
         * @param {Company} company 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdPut(companyId: string, company: Company, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<CreateCompanyResponse> {
            return localVarFp.companyCompanyIdPut(companyId, company, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Company on behalf of a customer account to include all managed network entities  i.e. Trusted Parties, Holdings, Funds, Custody Policies and those for the movement of assets (deposits, transfers, and withdrawals).
         * @summary Create Company
         * @param {Company} company 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyPost(company: Company, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<CreateCompanyResponse> {
            return localVarFp.companyPost(company, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for a Company in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all companies where those letters exist.
         * @summary Search Company
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companySearchGet(xNonce?: string, xTimestamp?: string, xSign?: string, query?: string, options?: any): AxiosPromise<CompanySearchResponse> {
            return localVarFp.companySearchGet(xNonce, xTimestamp, xSign, query, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompanyApi - object-oriented interface
 * @export
 * @class CompanyApi
 * @extends {BaseAPI}
 */
export class CompanyApi extends BaseAPI {
    /**
     * returns details of a Company from the Company ID.
     * @summary Get Company
     * @param {string} companyId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public companyCompanyIdGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return CompanyApiFp(this.configuration).companyCompanyIdGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change details of a Company
     * @summary Update Company
     * @param {string} companyId 
     * @param {Company} company 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public companyCompanyIdPut(companyId: string, company: Company, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return CompanyApiFp(this.configuration).companyCompanyIdPut(companyId, company, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Company on behalf of a customer account to include all managed network entities  i.e. Trusted Parties, Holdings, Funds, Custody Policies and those for the movement of assets (deposits, transfers, and withdrawals).
     * @summary Create Company
     * @param {Company} company 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public companyPost(company: Company, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return CompanyApiFp(this.configuration).companyPost(company, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for a Company in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all companies where those letters exist.
     * @summary Search Company
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public companySearchGet(xNonce?: string, xTimestamp?: string, xSign?: string, query?: string, options?: AxiosRequestConfig) {
        return CompanyApiFp(this.configuration).companySearchGet(xNonce, xTimestamp, xSign, query, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoreClientApi - axios parameter creator
 * @export
 */
export const CoreClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Reject a specific action
         * @param {string} clientId 
         * @param {string} actionId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdDelete: async (clientId: string, actionId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('coreclientClientIdActionActionIdDelete', 'clientId', clientId)
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('coreclientClientIdActionActionIdDelete', 'actionId', actionId)
            const localVarPath = `/coreclient/{client_id}/action/{action_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)))
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of an action including Type, Status, Timestamp and Expiry Time.
         * @summary Details of an action
         * @param {string} clientId 
         * @param {string} actionId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdGet: async (clientId: string, actionId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('coreclientClientIdActionActionIdGet', 'clientId', clientId)
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('coreclientClientIdActionActionIdGet', 'actionId', actionId)
            const localVarPath = `/coreclient/{client_id}/action/{action_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)))
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve a specific action
         * @summary Approve action
         * @param {string} clientId 
         * @param {string} actionId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdPut: async (clientId: string, actionId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('coreclientClientIdActionActionIdPut', 'clientId', clientId)
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('coreclientClientIdActionActionIdPut', 'actionId', actionId)
            const localVarPath = `/coreclient/{client_id}/action/{action_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)))
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns actions with a status of \'Pending\'
         * @summary Pending actions
         * @param {string} clientId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionsGet: async (clientId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('coreclientClientIdActionsGet', 'clientId', clientId)
            const localVarPath = `/coreclient/{client_id}/actions`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain details on connected wallets and wallets pending approval
         * @summary Get connected wallets
         * @param {string} clientId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdWalletsGet: async (clientId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('coreclientClientIdWalletsGet', 'clientId', clientId)
            const localVarPath = `/coreclient/{client_id}/wallets`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all registered Core Clients
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientGet: async (xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coreclient`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Core Client
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {NewCoreClient} [newCoreClient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientPost: async (xNonce?: string, xTimestamp?: string, xSign?: string, newCoreClient?: NewCoreClient, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coreclient`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newCoreClient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreClientApi - functional programming interface
 * @export
 */
export const CoreClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoreClientApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Reject a specific action
         * @param {string} clientId 
         * @param {string} actionId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientClientIdActionActionIdDelete(clientId: string, actionId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientClientIdActionActionIdDelete(clientId, actionId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of an action including Type, Status, Timestamp and Expiry Time.
         * @summary Details of an action
         * @param {string} clientId 
         * @param {string} actionId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientClientIdActionActionIdGet(clientId: string, actionId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientClientIdActionActionIdGet(clientId, actionId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Approve a specific action
         * @summary Approve action
         * @param {string} clientId 
         * @param {string} actionId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientClientIdActionActionIdPut(clientId: string, actionId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientClientIdActionActionIdPut(clientId, actionId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns actions with a status of \'Pending\'
         * @summary Pending actions
         * @param {string} clientId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientClientIdActionsGet(clientId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientClientIdActionsGet(clientId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Obtain details on connected wallets and wallets pending approval
         * @summary Get connected wallets
         * @param {string} clientId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientClientIdWalletsGet(clientId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreclientClientIdWalletsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientClientIdWalletsGet(clientId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of all registered Core Clients
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientGet(xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreClientsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientGet(xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Core Client
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {NewCoreClient} [newCoreClient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientPost(xNonce?: string, xTimestamp?: string, xSign?: string, newCoreClient?: NewCoreClient, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreClientInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientPost(xNonce, xTimestamp, xSign, newCoreClient, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoreClientApi - factory interface
 * @export
 */
export const CoreClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoreClientApiFp(configuration)
    return {
        /**
         * 
         * @summary Reject a specific action
         * @param {string} clientId 
         * @param {string} actionId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdDelete(clientId: string, actionId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<ActionDetails> {
            return localVarFp.coreclientClientIdActionActionIdDelete(clientId, actionId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of an action including Type, Status, Timestamp and Expiry Time.
         * @summary Details of an action
         * @param {string} clientId 
         * @param {string} actionId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdGet(clientId: string, actionId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<ActionDetails> {
            return localVarFp.coreclientClientIdActionActionIdGet(clientId, actionId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve a specific action
         * @summary Approve action
         * @param {string} clientId 
         * @param {string} actionId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionActionIdPut(clientId: string, actionId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<ActionDetails> {
            return localVarFp.coreclientClientIdActionActionIdPut(clientId, actionId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns actions with a status of \'Pending\'
         * @summary Pending actions
         * @param {string} clientId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdActionsGet(clientId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<ActionsInfo> {
            return localVarFp.coreclientClientIdActionsGet(clientId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain details on connected wallets and wallets pending approval
         * @summary Get connected wallets
         * @param {string} clientId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdWalletsGet(clientId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<CoreclientClientIdWalletsGet200Response> {
            return localVarFp.coreclientClientIdWalletsGet(clientId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all registered Core Clients
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientGet(xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<CoreClientsInfo> {
            return localVarFp.coreclientGet(xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Core Client
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {NewCoreClient} [newCoreClient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientPost(xNonce?: string, xTimestamp?: string, xSign?: string, newCoreClient?: NewCoreClient, options?: any): AxiosPromise<CoreClientInfo> {
            return localVarFp.coreclientPost(xNonce, xTimestamp, xSign, newCoreClient, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoreClientApi - object-oriented interface
 * @export
 * @class CoreClientApi
 * @extends {BaseAPI}
 */
export class CoreClientApi extends BaseAPI {
    /**
     * 
     * @summary Reject a specific action
     * @param {string} clientId 
     * @param {string} actionId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    public coreclientClientIdActionActionIdDelete(clientId: string, actionId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return CoreClientApiFp(this.configuration).coreclientClientIdActionActionIdDelete(clientId, actionId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of an action including Type, Status, Timestamp and Expiry Time.
     * @summary Details of an action
     * @param {string} clientId 
     * @param {string} actionId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    public coreclientClientIdActionActionIdGet(clientId: string, actionId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return CoreClientApiFp(this.configuration).coreclientClientIdActionActionIdGet(clientId, actionId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approve a specific action
     * @summary Approve action
     * @param {string} clientId 
     * @param {string} actionId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    public coreclientClientIdActionActionIdPut(clientId: string, actionId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return CoreClientApiFp(this.configuration).coreclientClientIdActionActionIdPut(clientId, actionId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns actions with a status of \'Pending\'
     * @summary Pending actions
     * @param {string} clientId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    public coreclientClientIdActionsGet(clientId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return CoreClientApiFp(this.configuration).coreclientClientIdActionsGet(clientId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtain details on connected wallets and wallets pending approval
     * @summary Get connected wallets
     * @param {string} clientId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    public coreclientClientIdWalletsGet(clientId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return CoreClientApiFp(this.configuration).coreclientClientIdWalletsGet(clientId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all registered Core Clients
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    public coreclientGet(xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return CoreClientApiFp(this.configuration).coreclientGet(xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Core Client
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {NewCoreClient} [newCoreClient] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientApi
     */
    public coreclientPost(xNonce?: string, xTimestamp?: string, xSign?: string, newCoreClient?: NewCoreClient, options?: AxiosRequestConfig) {
        return CoreClientApiFp(this.configuration).coreclientPost(xNonce, xTimestamp, xSign, newCoreClient, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoreClientSignApi - axios parameter creator
 * @export
 */
export const CoreClientSignApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Signs a hash message with the core client\'s BLS key. The message should be no bigger than 64 bytes, hex encoded
         * @summary Sign a hash
         * @param {string} clientId 
         * @param {CoreClientSign} coreClientSign 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSignPost: async (clientId: string, coreClientSign: CoreClientSign, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('coreclientClientIdSignPost', 'clientId', clientId)
            // verify required parameter 'coreClientSign' is not null or undefined
            assertParamExists('coreclientClientIdSignPost', 'coreClientSign', coreClientSign)
            const localVarPath = `/coreclient/{client_id}/sign`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(coreClientSign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies a signature
         * @summary Verify signature
         * @param {CoreClientVerifySignature} coreClientVerifySignature 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientVerifyPost: async (coreClientVerifySignature: CoreClientVerifySignature, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coreClientVerifySignature' is not null or undefined
            assertParamExists('coreclientVerifyPost', 'coreClientVerifySignature', coreClientVerifySignature)
            const localVarPath = `/coreclient/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(coreClientVerifySignature, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreClientSignApi - functional programming interface
 * @export
 */
export const CoreClientSignApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoreClientSignApiAxiosParamCreator(configuration)
    return {
        /**
         * Signs a hash message with the core client\'s BLS key. The message should be no bigger than 64 bytes, hex encoded
         * @summary Sign a hash
         * @param {string} clientId 
         * @param {CoreClientSign} coreClientSign 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientClientIdSignPost(clientId: string, coreClientSign: CoreClientSign, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreClientSignature>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientClientIdSignPost(clientId, coreClientSign, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verifies a signature
         * @summary Verify signature
         * @param {CoreClientVerifySignature} coreClientVerifySignature 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientVerifyPost(coreClientVerifySignature: CoreClientVerifySignature, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientVerifyPost(coreClientVerifySignature, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoreClientSignApi - factory interface
 * @export
 */
export const CoreClientSignApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoreClientSignApiFp(configuration)
    return {
        /**
         * Signs a hash message with the core client\'s BLS key. The message should be no bigger than 64 bytes, hex encoded
         * @summary Sign a hash
         * @param {string} clientId 
         * @param {CoreClientSign} coreClientSign 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSignPost(clientId: string, coreClientSign: CoreClientSign, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<CoreClientSignature> {
            return localVarFp.coreclientClientIdSignPost(clientId, coreClientSign, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies a signature
         * @summary Verify signature
         * @param {CoreClientVerifySignature} coreClientVerifySignature 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientVerifyPost(coreClientVerifySignature: CoreClientVerifySignature, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<void> {
            return localVarFp.coreclientVerifyPost(coreClientVerifySignature, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoreClientSignApi - object-oriented interface
 * @export
 * @class CoreClientSignApi
 * @extends {BaseAPI}
 */
export class CoreClientSignApi extends BaseAPI {
    /**
     * Signs a hash message with the core client\'s BLS key. The message should be no bigger than 64 bytes, hex encoded
     * @summary Sign a hash
     * @param {string} clientId 
     * @param {CoreClientSign} coreClientSign 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientSignApi
     */
    public coreclientClientIdSignPost(clientId: string, coreClientSign: CoreClientSign, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return CoreClientSignApiFp(this.configuration).coreclientClientIdSignPost(clientId, coreClientSign, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies a signature
     * @summary Verify signature
     * @param {CoreClientVerifySignature} coreClientVerifySignature 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClientSignApi
     */
    public coreclientVerifyPost(coreClientVerifySignature: CoreClientVerifySignature, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return CoreClientSignApiFp(this.configuration).coreclientVerifyPost(coreClientVerifySignature, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FundApi - axios parameter creator
 * @export
 */
export const FundApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an Asset to an existing fund
         * @summary Add Asset to a fund
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {FundAsset} fundAsset 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdAssetPost: async (companyId: string, fundId: string, fundAsset: FundAsset, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdAssetPost', 'companyId', companyId)
            // verify required parameter 'fundId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdAssetPost', 'fundId', fundId)
            // verify required parameter 'fundAsset' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdAssetPost', 'fundAsset', fundAsset)
            const localVarPath = `/company/{company_id}/fund/{fund_id}/asset`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fundAsset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns a list of fund assets with their Deposit Addresses and current balances. Each fund contains one or more deposit addresses for the different types of assets.
         * @summary Get Fund Deposit Address
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdDepositGet: async (companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdDepositGet', 'companyId', companyId)
            // verify required parameter 'fundId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdDepositGet', 'fundId', fundId)
            const localVarPath = `/company/{company_id}/fund/{fund_id}/deposit`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns basic information on the Fund including the custody groups for withdrawal and transfers. There are also details on fund members who are part of each custody group.
         * @summary Get Fund
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdGet: async (companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdGet', 'companyId', companyId)
            // verify required parameter 'fundId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdGet', 'fundId', fundId)
            const localVarPath = `/company/{company_id}/fund/{fund_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get transaction ledger for a fund
         * @summary Transaction ledger
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {string} [asset] 
         * @param {string} [walletId] 
         * @param {'all' | 'in' | 'out'} [direction] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdLedgerGet: async (companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, asset?: string, walletId?: string, direction?: 'all' | 'in' | 'out', offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdLedgerGet', 'companyId', companyId)
            // verify required parameter 'fundId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdLedgerGet', 'fundId', fundId)
            const localVarPath = `/company/{company_id}/fund/{fund_id}/ledger`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (walletId !== undefined) {
                localVarQueryParameter['wallet_id'] = walletId;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
         * @summary Add Wallet to a fund
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {FundWallet} fundWallet 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWalletPost: async (companyId: string, fundId: string, fundWallet: FundWallet, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdWalletPost', 'companyId', companyId)
            // verify required parameter 'fundId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdWalletPost', 'fundId', fundId)
            // verify required parameter 'fundWallet' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdWalletPost', 'fundWallet', fundWallet)
            const localVarPath = `/company/{company_id}/fund/{fund_id}/wallet`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fundWallet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Whitelisted addresses for fund transactions.
         * @summary Get Fund Whitelist
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {string} [address] 
         * @param {string} [asset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWhitelistGet: async (companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, address?: string, asset?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdWhitelistGet', 'companyId', companyId)
            // verify required parameter 'fundId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdWhitelistGet', 'fundId', fundId)
            const localVarPath = `/company/{company_id}/fund/{fund_id}/whitelist`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An address needs to be Whitelisted to ensure it is approved for a withdrawal transaction.
         * @summary Add Whitelist address
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {AddFundWhitelist} addFundWhitelist 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWhitelistPost: async (companyId: string, fundId: string, addFundWhitelist: AddFundWhitelist, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdWhitelistPost', 'companyId', companyId)
            // verify required parameter 'fundId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdWhitelistPost', 'fundId', fundId)
            // verify required parameter 'addFundWhitelist' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdWhitelistPost', 'addFundWhitelist', addFundWhitelist)
            const localVarPath = `/company/{company_id}/fund/{fund_id}/whitelist`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addFundWhitelist, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Fund that serves as a wallet containing assets, addresses, and custody policies. Custody policies for both deposits and withdrawals must exist for a fund. Policies can include multiple custodians, or a single user that self-manages custody. For an individual fund, you can also add whitelisted withdrawal addresses.
         * @summary Add Fund
         * @param {string} companyId 
         * @param {Fund} fund 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundPost: async (companyId: string, fund: Fund, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdFundPost', 'companyId', companyId)
            // verify required parameter 'fund' is not null or undefined
            assertParamExists('companyCompanyIdFundPost', 'fund', fund)
            const localVarPath = `/company/{company_id}/fund`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fund, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search funds in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all funds where those letters exist.
         * @summary Search Fund
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundSearchGet: async (companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, query?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdFundSearchGet', 'companyId', companyId)
            const localVarPath = `/company/{company_id}/fund/search`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FundApi - functional programming interface
 * @export
 */
export const FundApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FundApiAxiosParamCreator(configuration)
    return {
        /**
         * Add an Asset to an existing fund
         * @summary Add Asset to a fund
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {FundAsset} fundAsset 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdFundFundIdAssetPost(companyId: string, fundId: string, fundAsset: FundAsset, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletIDList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdFundFundIdAssetPost(companyId, fundId, fundAsset, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns a list of fund assets with their Deposit Addresses and current balances. Each fund contains one or more deposit addresses for the different types of assets.
         * @summary Get Fund Deposit Address
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdFundFundIdDepositGet(companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdFundFundIdDepositGet(companyId, fundId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns basic information on the Fund including the custody groups for withdrawal and transfers. There are also details on fund members who are part of each custody group.
         * @summary Get Fund
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdFundFundIdGet(companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdFundFundIdGet(companyId, fundId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get transaction ledger for a fund
         * @summary Transaction ledger
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {string} [asset] 
         * @param {string} [walletId] 
         * @param {'all' | 'in' | 'out'} [direction] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdFundFundIdLedgerGet(companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, asset?: string, walletId?: string, direction?: 'all' | 'in' | 'out', offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxLedger>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdFundFundIdLedgerGet(companyId, fundId, xNonce, xTimestamp, xSign, asset, walletId, direction, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
         * @summary Add Wallet to a fund
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {FundWallet} fundWallet 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdFundFundIdWalletPost(companyId: string, fundId: string, fundWallet: FundWallet, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletIDList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Whitelisted addresses for fund transactions.
         * @summary Get Fund Whitelist
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {string} [address] 
         * @param {string} [asset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdFundFundIdWhitelistGet(companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, address?: string, asset?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundWhitelist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdFundFundIdWhitelistGet(companyId, fundId, xNonce, xTimestamp, xSign, address, asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An address needs to be Whitelisted to ensure it is approved for a withdrawal transaction.
         * @summary Add Whitelist address
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {AddFundWhitelist} addFundWhitelist 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdFundFundIdWhitelistPost(companyId: string, fundId: string, addFundWhitelist: AddFundWhitelist, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdFundFundIdWhitelistPost(companyId, fundId, addFundWhitelist, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Fund that serves as a wallet containing assets, addresses, and custody policies. Custody policies for both deposits and withdrawals must exist for a fund. Policies can include multiple custodians, or a single user that self-manages custody. For an individual fund, you can also add whitelisted withdrawal addresses.
         * @summary Add Fund
         * @param {string} companyId 
         * @param {Fund} fund 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdFundPost(companyId: string, fund: Fund, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdFundPost(companyId, fund, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search funds in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all funds where those letters exist.
         * @summary Search Fund
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdFundSearchGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, query?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundSearchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdFundSearchGet(companyId, xNonce, xTimestamp, xSign, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FundApi - factory interface
 * @export
 */
export const FundApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FundApiFp(configuration)
    return {
        /**
         * Add an Asset to an existing fund
         * @summary Add Asset to a fund
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {FundAsset} fundAsset 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdAssetPost(companyId: string, fundId: string, fundAsset: FundAsset, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<WalletIDList> {
            return localVarFp.companyCompanyIdFundFundIdAssetPost(companyId, fundId, fundAsset, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * returns a list of fund assets with their Deposit Addresses and current balances. Each fund contains one or more deposit addresses for the different types of assets.
         * @summary Get Fund Deposit Address
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdDepositGet(companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<FundDepositResponse> {
            return localVarFp.companyCompanyIdFundFundIdDepositGet(companyId, fundId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * returns basic information on the Fund including the custody groups for withdrawal and transfers. There are also details on fund members who are part of each custody group.
         * @summary Get Fund
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdGet(companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<FundDetail> {
            return localVarFp.companyCompanyIdFundFundIdGet(companyId, fundId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Get transaction ledger for a fund
         * @summary Transaction ledger
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {string} [asset] 
         * @param {string} [walletId] 
         * @param {'all' | 'in' | 'out'} [direction] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdLedgerGet(companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, asset?: string, walletId?: string, direction?: 'all' | 'in' | 'out', offset?: number, limit?: number, options?: any): AxiosPromise<TxLedger> {
            return localVarFp.companyCompanyIdFundFundIdLedgerGet(companyId, fundId, xNonce, xTimestamp, xSign, asset, walletId, direction, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
         * @summary Add Wallet to a fund
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {FundWallet} fundWallet 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWalletPost(companyId: string, fundId: string, fundWallet: FundWallet, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<WalletIDList> {
            return localVarFp.companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Whitelisted addresses for fund transactions.
         * @summary Get Fund Whitelist
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {string} [address] 
         * @param {string} [asset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWhitelistGet(companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, address?: string, asset?: string, options?: any): AxiosPromise<FundWhitelist> {
            return localVarFp.companyCompanyIdFundFundIdWhitelistGet(companyId, fundId, xNonce, xTimestamp, xSign, address, asset, options).then((request) => request(axios, basePath));
        },
        /**
         * An address needs to be Whitelisted to ensure it is approved for a withdrawal transaction.
         * @summary Add Whitelist address
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {AddFundWhitelist} addFundWhitelist 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWhitelistPost(companyId: string, fundId: string, addFundWhitelist: AddFundWhitelist, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<any> {
            return localVarFp.companyCompanyIdFundFundIdWhitelistPost(companyId, fundId, addFundWhitelist, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Fund that serves as a wallet containing assets, addresses, and custody policies. Custody policies for both deposits and withdrawals must exist for a fund. Policies can include multiple custodians, or a single user that self-manages custody. For an individual fund, you can also add whitelisted withdrawal addresses.
         * @summary Add Fund
         * @param {string} companyId 
         * @param {Fund} fund 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundPost(companyId: string, fund: Fund, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<CreateFundResponse> {
            return localVarFp.companyCompanyIdFundPost(companyId, fund, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Search funds in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all funds where those letters exist.
         * @summary Search Fund
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundSearchGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, query?: string, options?: any): AxiosPromise<FundSearchResult> {
            return localVarFp.companyCompanyIdFundSearchGet(companyId, xNonce, xTimestamp, xSign, query, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FundApi - object-oriented interface
 * @export
 * @class FundApi
 * @extends {BaseAPI}
 */
export class FundApi extends BaseAPI {
    /**
     * Add an Asset to an existing fund
     * @summary Add Asset to a fund
     * @param {string} companyId 
     * @param {string} fundId 
     * @param {FundAsset} fundAsset 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public companyCompanyIdFundFundIdAssetPost(companyId: string, fundId: string, fundAsset: FundAsset, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return FundApiFp(this.configuration).companyCompanyIdFundFundIdAssetPost(companyId, fundId, fundAsset, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns a list of fund assets with their Deposit Addresses and current balances. Each fund contains one or more deposit addresses for the different types of assets.
     * @summary Get Fund Deposit Address
     * @param {string} companyId 
     * @param {string} fundId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public companyCompanyIdFundFundIdDepositGet(companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return FundApiFp(this.configuration).companyCompanyIdFundFundIdDepositGet(companyId, fundId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns basic information on the Fund including the custody groups for withdrawal and transfers. There are also details on fund members who are part of each custody group.
     * @summary Get Fund
     * @param {string} companyId 
     * @param {string} fundId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public companyCompanyIdFundFundIdGet(companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return FundApiFp(this.configuration).companyCompanyIdFundFundIdGet(companyId, fundId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get transaction ledger for a fund
     * @summary Transaction ledger
     * @param {string} companyId 
     * @param {string} fundId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {string} [asset] 
     * @param {string} [walletId] 
     * @param {'all' | 'in' | 'out'} [direction] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public companyCompanyIdFundFundIdLedgerGet(companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, asset?: string, walletId?: string, direction?: 'all' | 'in' | 'out', offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return FundApiFp(this.configuration).companyCompanyIdFundFundIdLedgerGet(companyId, fundId, xNonce, xTimestamp, xSign, asset, walletId, direction, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
     * @summary Add Wallet to a fund
     * @param {string} companyId 
     * @param {string} fundId 
     * @param {FundWallet} fundWallet 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public companyCompanyIdFundFundIdWalletPost(companyId: string, fundId: string, fundWallet: FundWallet, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return FundApiFp(this.configuration).companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Whitelisted addresses for fund transactions.
     * @summary Get Fund Whitelist
     * @param {string} companyId 
     * @param {string} fundId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {string} [address] 
     * @param {string} [asset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public companyCompanyIdFundFundIdWhitelistGet(companyId: string, fundId: string, xNonce?: string, xTimestamp?: string, xSign?: string, address?: string, asset?: string, options?: AxiosRequestConfig) {
        return FundApiFp(this.configuration).companyCompanyIdFundFundIdWhitelistGet(companyId, fundId, xNonce, xTimestamp, xSign, address, asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * An address needs to be Whitelisted to ensure it is approved for a withdrawal transaction.
     * @summary Add Whitelist address
     * @param {string} companyId 
     * @param {string} fundId 
     * @param {AddFundWhitelist} addFundWhitelist 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public companyCompanyIdFundFundIdWhitelistPost(companyId: string, fundId: string, addFundWhitelist: AddFundWhitelist, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return FundApiFp(this.configuration).companyCompanyIdFundFundIdWhitelistPost(companyId, fundId, addFundWhitelist, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Fund that serves as a wallet containing assets, addresses, and custody policies. Custody policies for both deposits and withdrawals must exist for a fund. Policies can include multiple custodians, or a single user that self-manages custody. For an individual fund, you can also add whitelisted withdrawal addresses.
     * @summary Add Fund
     * @param {string} companyId 
     * @param {Fund} fund 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public companyCompanyIdFundPost(companyId: string, fund: Fund, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return FundApiFp(this.configuration).companyCompanyIdFundPost(companyId, fund, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search funds in the database using the string entered in the query parameter for matching. For example, entering 3 letters returns all funds where those letters exist.
     * @summary Search Fund
     * @param {string} companyId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public companyCompanyIdFundSearchGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, query?: string, options?: AxiosRequestConfig) {
        return FundApiFp(this.configuration).companyCompanyIdFundSearchGet(companyId, xNonce, xTimestamp, xSign, query, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HoldingApi - axios parameter creator
 * @export
 */
export const HoldingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * returns information on all the assets for a company on the Qredo network. Each Holding is divided according to the asset type. Each Holding entry also includes the balance for that asset, allowing you to track funds coming in and out.
         * @summary Get Holdings
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdHoldingGet: async (companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdHoldingGet', 'companyId', companyId)
            const localVarPath = `/company/{company_id}/holding`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HoldingApi - functional programming interface
 * @export
 */
export const HoldingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HoldingApiAxiosParamCreator(configuration)
    return {
        /**
         * returns information on all the assets for a company on the Qredo network. Each Holding is divided according to the asset type. Each Holding entry also includes the balance for that asset, allowing you to track funds coming in and out.
         * @summary Get Holdings
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdHoldingGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Holdings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdHoldingGet(companyId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HoldingApi - factory interface
 * @export
 */
export const HoldingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HoldingApiFp(configuration)
    return {
        /**
         * returns information on all the assets for a company on the Qredo network. Each Holding is divided according to the asset type. Each Holding entry also includes the balance for that asset, allowing you to track funds coming in and out.
         * @summary Get Holdings
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdHoldingGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<Holdings> {
            return localVarFp.companyCompanyIdHoldingGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HoldingApi - object-oriented interface
 * @export
 * @class HoldingApi
 * @extends {BaseAPI}
 */
export class HoldingApi extends BaseAPI {
    /**
     * returns information on all the assets for a company on the Qredo network. Each Holding is divided according to the asset type. Each Holding entry also includes the balance for that asset, allowing you to track funds coming in and out.
     * @summary Get Holdings
     * @param {string} companyId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HoldingApi
     */
    public companyCompanyIdHoldingGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return HoldingApiFp(this.configuration).companyCompanyIdHoldingGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LiquidityHubApi - axios parameter creator
 * @export
 */
export const LiquidityHubApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
         * @summary Get Liquidity Hub
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdLiquidityhubGet: async (companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdLiquidityhubGet', 'companyId', companyId)
            const localVarPath = `/company/{company_id}/liquidityhub`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an existing swap to the liquidity hub.
         * @summary Add to liquidity hub
         * @param {string} companyId 
         * @param {AddToLiquidityHub} addToLiquidityHub 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdLiquidityhubPost: async (companyId: string, addToLiquidityHub: AddToLiquidityHub, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdLiquidityhubPost', 'companyId', companyId)
            // verify required parameter 'addToLiquidityHub' is not null or undefined
            assertParamExists('companyCompanyIdLiquidityhubPost', 'addToLiquidityHub', addToLiquidityHub)
            const localVarPath = `/company/{company_id}/liquidityhub`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addToLiquidityHub, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
         * @summary Get Liquidity Hub
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityhubGet: async (xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liquidityhub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiquidityHubApi - functional programming interface
 * @export
 */
export const LiquidityHubApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiquidityHubApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
         * @summary Get Liquidity Hub
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdLiquidityhubGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidityHub>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdLiquidityhubGet(companyId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add an existing swap to the liquidity hub.
         * @summary Add to liquidity hub
         * @param {string} companyId 
         * @param {AddToLiquidityHub} addToLiquidityHub 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdLiquidityhubPost(companyId: string, addToLiquidityHub: AddToLiquidityHub, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdLiquidityhubPost(companyId, addToLiquidityHub, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
         * @summary Get Liquidity Hub
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityhubGet(xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidityHub>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liquidityhubGet(xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LiquidityHubApi - factory interface
 * @export
 */
export const LiquidityHubApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiquidityHubApiFp(configuration)
    return {
        /**
         * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
         * @summary Get Liquidity Hub
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdLiquidityhubGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<LiquidityHub> {
            return localVarFp.companyCompanyIdLiquidityhubGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an existing swap to the liquidity hub.
         * @summary Add to liquidity hub
         * @param {string} companyId 
         * @param {AddToLiquidityHub} addToLiquidityHub 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdLiquidityhubPost(companyId: string, addToLiquidityHub: AddToLiquidityHub, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<any> {
            return localVarFp.companyCompanyIdLiquidityhubPost(companyId, addToLiquidityHub, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
         * @summary Get Liquidity Hub
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityhubGet(xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<LiquidityHub> {
            return localVarFp.liquidityhubGet(xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiquidityHubApi - object-oriented interface
 * @export
 * @class LiquidityHubApi
 * @extends {BaseAPI}
 */
export class LiquidityHubApi extends BaseAPI {
    /**
     * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
     * @summary Get Liquidity Hub
     * @param {string} companyId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityHubApi
     */
    public companyCompanyIdLiquidityhubGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return LiquidityHubApiFp(this.configuration).companyCompanyIdLiquidityhubGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an existing swap to the liquidity hub.
     * @summary Add to liquidity hub
     * @param {string} companyId 
     * @param {AddToLiquidityHub} addToLiquidityHub 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityHubApi
     */
    public companyCompanyIdLiquidityhubPost(companyId: string, addToLiquidityHub: AddToLiquidityHub, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return LiquidityHubApiFp(this.configuration).companyCompanyIdLiquidityhubPost(companyId, addToLiquidityHub, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the active swaps in the liquidity hub. You can use websocket connection to get live notifications when a new swap is added to the liquidity hub using this endpoint: wss://api.qredo.network/api/v1/p/liquidityhub/feed
     * @summary Get Liquidity Hub
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityHubApi
     */
    public liquidityhubGet(xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return LiquidityHubApiFp(this.configuration).liquidityhubGet(xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SweepApi - axios parameter creator
 * @export
 */
export const SweepApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiate a new sweep transactions and set parameters for the transaction.
         * @summary New sweep
         * @param {string} clientId 
         * @param {Sweep} sweep 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSweepPost: async (clientId: string, sweep: Sweep, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('coreclientClientIdSweepPost', 'clientId', clientId)
            // verify required parameter 'sweep' is not null or undefined
            assertParamExists('coreclientClientIdSweepPost', 'sweep', sweep)
            const localVarPath = `/coreclient/{client_id}/sweep`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sweep, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain details on a sweep transaction status
         * @summary Get sweep status
         * @param {string} clientId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSweepTxIdGet: async (clientId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('coreclientClientIdSweepTxIdGet', 'clientId', clientId)
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('coreclientClientIdSweepTxIdGet', 'txId', txId)
            const localVarPath = `/coreclient/{client_id}/sweep/{tx_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)))
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SweepApi - functional programming interface
 * @export
 */
export const SweepApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SweepApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiate a new sweep transactions and set parameters for the transaction.
         * @summary New sweep
         * @param {string} clientId 
         * @param {Sweep} sweep 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientClientIdSweepPost(clientId: string, sweep: Sweep, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientClientIdSweepPost(clientId, sweep, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Obtain details on a sweep transaction status
         * @summary Get sweep status
         * @param {string} clientId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreclientClientIdSweepTxIdGet(clientId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SweepInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreclientClientIdSweepTxIdGet(clientId, txId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SweepApi - factory interface
 * @export
 */
export const SweepApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SweepApiFp(configuration)
    return {
        /**
         * Initiate a new sweep transactions and set parameters for the transaction.
         * @summary New sweep
         * @param {string} clientId 
         * @param {Sweep} sweep 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSweepPost(clientId: string, sweep: Sweep, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<TxId> {
            return localVarFp.coreclientClientIdSweepPost(clientId, sweep, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain details on a sweep transaction status
         * @summary Get sweep status
         * @param {string} clientId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreclientClientIdSweepTxIdGet(clientId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<SweepInfo> {
            return localVarFp.coreclientClientIdSweepTxIdGet(clientId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SweepApi - object-oriented interface
 * @export
 * @class SweepApi
 * @extends {BaseAPI}
 */
export class SweepApi extends BaseAPI {
    /**
     * Initiate a new sweep transactions and set parameters for the transaction.
     * @summary New sweep
     * @param {string} clientId 
     * @param {Sweep} sweep 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SweepApi
     */
    public coreclientClientIdSweepPost(clientId: string, sweep: Sweep, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return SweepApiFp(this.configuration).coreclientClientIdSweepPost(clientId, sweep, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtain details on a sweep transaction status
     * @summary Get sweep status
     * @param {string} clientId 
     * @param {string} txId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SweepApi
     */
    public coreclientClientIdSweepTxIdGet(clientId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return SweepApiFp(this.configuration).coreclientClientIdSweepTxIdGet(clientId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransferApi - axios parameter creator
 * @export
 */
export const TransferApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiate a new Transfer on a fund that includes various settings for the transaction. When a transfer transaction is created, custodian(s) need to approve it via their Qredo Signing app. The number of custodian approvals depends on the Transfer Policy settings for the fund.
         * @summary New Transfer
         * @param {string} companyId 
         * @param {Transfer} transfer 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTransferPost: async (companyId: string, transfer: Transfer, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdTransferPost', 'companyId', companyId)
            // verify required parameter 'transfer' is not null or undefined
            assertParamExists('companyCompanyIdTransferPost', 'transfer', transfer)
            const localVarPath = `/company/{company_id}/transfer`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns the Transfer Status for a specific transaction at that point in time.
         * @summary Get Transfer Status
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTransferTxIdGet: async (companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdTransferTxIdGet', 'companyId', companyId)
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('companyCompanyIdTransferTxIdGet', 'txId', txId)
            const localVarPath = `/company/{company_id}/transfer/{tx_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransferApi - functional programming interface
 * @export
 */
export const TransferApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransferApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiate a new Transfer on a fund that includes various settings for the transaction. When a transfer transaction is created, custodian(s) need to approve it via their Qredo Signing app. The number of custodian approvals depends on the Transfer Policy settings for the fund.
         * @summary New Transfer
         * @param {string} companyId 
         * @param {Transfer} transfer 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdTransferPost(companyId: string, transfer: Transfer, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdTransferPost(companyId, transfer, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns the Transfer Status for a specific transaction at that point in time.
         * @summary Get Transfer Status
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdTransferTxIdGet(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdTransferTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransferApi - factory interface
 * @export
 */
export const TransferApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransferApiFp(configuration)
    return {
        /**
         * Initiate a new Transfer on a fund that includes various settings for the transaction. When a transfer transaction is created, custodian(s) need to approve it via their Qredo Signing app. The number of custodian approvals depends on the Transfer Policy settings for the fund.
         * @summary New Transfer
         * @param {string} companyId 
         * @param {Transfer} transfer 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTransferPost(companyId: string, transfer: Transfer, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<TxId> {
            return localVarFp.companyCompanyIdTransferPost(companyId, transfer, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * returns the Transfer Status for a specific transaction at that point in time.
         * @summary Get Transfer Status
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTransferTxIdGet(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<TxInfo> {
            return localVarFp.companyCompanyIdTransferTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransferApi - object-oriented interface
 * @export
 * @class TransferApi
 * @extends {BaseAPI}
 */
export class TransferApi extends BaseAPI {
    /**
     * Initiate a new Transfer on a fund that includes various settings for the transaction. When a transfer transaction is created, custodian(s) need to approve it via their Qredo Signing app. The number of custodian approvals depends on the Transfer Policy settings for the fund.
     * @summary New Transfer
     * @param {string} companyId 
     * @param {Transfer} transfer 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferApi
     */
    public companyCompanyIdTransferPost(companyId: string, transfer: Transfer, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return TransferApiFp(this.configuration).companyCompanyIdTransferPost(companyId, transfer, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns the Transfer Status for a specific transaction at that point in time.
     * @summary Get Transfer Status
     * @param {string} companyId 
     * @param {string} txId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferApi
     */
    public companyCompanyIdTransferTxIdGet(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return TransferApiFp(this.configuration).companyCompanyIdTransferTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrustedNetworkApi - axios parameter creator
 * @export
 */
export const TrustedNetworkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all Trusted Parties for a Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund.
         * @summary returns all Trusted Parties for a Company
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyGet: async (companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdTrustedpartyGet', 'companyId', companyId)
            const localVarPath = `/company/{company_id}/trustedparty`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a Trusted Party for the Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund. Qredo network as a Company or User.   When adding a user, they must approve this via their Qredo Signing App.
         * @summary Add Trusted Party
         * @param {string} companyId 
         * @param {TrustedPartyNew} trustedPartyNew 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyPost: async (companyId: string, trustedPartyNew: TrustedPartyNew, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdTrustedpartyPost', 'companyId', companyId)
            // verify required parameter 'trustedPartyNew' is not null or undefined
            assertParamExists('companyCompanyIdTrustedpartyPost', 'trustedPartyNew', trustedPartyNew)
            const localVarPath = `/company/{company_id}/trustedparty`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trustedPartyNew, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Trusted Party from the trusted network.
         * @summary Del Trusted party
         * @param {string} companyId 
         * @param {string} trustedpartyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyTrustedpartyIdDelete: async (companyId: string, trustedpartyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdTrustedpartyTrustedpartyIdDelete', 'companyId', companyId)
            // verify required parameter 'trustedpartyId' is not null or undefined
            assertParamExists('companyCompanyIdTrustedpartyTrustedpartyIdDelete', 'trustedpartyId', trustedpartyId)
            const localVarPath = `/company/{company_id}/trustedparty/{trustedparty_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"trustedparty_id"}}`, encodeURIComponent(String(trustedpartyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrustedNetworkApi - functional programming interface
 * @export
 */
export const TrustedNetworkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrustedNetworkApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all Trusted Parties for a Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund.
         * @summary returns all Trusted Parties for a Company
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdTrustedpartyGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrustedPartyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdTrustedpartyGet(companyId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a Trusted Party for the Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund. Qredo network as a Company or User.   When adding a user, they must approve this via their Qredo Signing App.
         * @summary Add Trusted Party
         * @param {string} companyId 
         * @param {TrustedPartyNew} trustedPartyNew 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdTrustedpartyPost(companyId: string, trustedPartyNew: TrustedPartyNew, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdTrustedpartyPost(companyId, trustedPartyNew, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a Trusted Party from the trusted network.
         * @summary Del Trusted party
         * @param {string} companyId 
         * @param {string} trustedpartyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdTrustedpartyTrustedpartyIdDelete(companyId: string, trustedpartyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdTrustedpartyTrustedpartyIdDelete(companyId, trustedpartyId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrustedNetworkApi - factory interface
 * @export
 */
export const TrustedNetworkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrustedNetworkApiFp(configuration)
    return {
        /**
         * Returns all Trusted Parties for a Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund.
         * @summary returns all Trusted Parties for a Company
         * @param {string} companyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<TrustedPartyList> {
            return localVarFp.companyCompanyIdTrustedpartyGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a Trusted Party for the Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund. Qredo network as a Company or User.   When adding a user, they must approve this via their Qredo Signing App.
         * @summary Add Trusted Party
         * @param {string} companyId 
         * @param {TrustedPartyNew} trustedPartyNew 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyPost(companyId: string, trustedPartyNew: TrustedPartyNew, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<OkResponse> {
            return localVarFp.companyCompanyIdTrustedpartyPost(companyId, trustedPartyNew, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Trusted Party from the trusted network.
         * @summary Del Trusted party
         * @param {string} companyId 
         * @param {string} trustedpartyId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdTrustedpartyTrustedpartyIdDelete(companyId: string, trustedpartyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<OkResponse> {
            return localVarFp.companyCompanyIdTrustedpartyTrustedpartyIdDelete(companyId, trustedpartyId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrustedNetworkApi - object-oriented interface
 * @export
 * @class TrustedNetworkApi
 * @extends {BaseAPI}
 */
export class TrustedNetworkApi extends BaseAPI {
    /**
     * Returns all Trusted Parties for a Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund.
     * @summary returns all Trusted Parties for a Company
     * @param {string} companyId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrustedNetworkApi
     */
    public companyCompanyIdTrustedpartyGet(companyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return TrustedNetworkApiFp(this.configuration).companyCompanyIdTrustedpartyGet(companyId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a Trusted Party for the Company. A Trusted Party is a user that can be added as a custodian of a wallet or member of a fund. Qredo network as a Company or User.   When adding a user, they must approve this via their Qredo Signing App.
     * @summary Add Trusted Party
     * @param {string} companyId 
     * @param {TrustedPartyNew} trustedPartyNew 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrustedNetworkApi
     */
    public companyCompanyIdTrustedpartyPost(companyId: string, trustedPartyNew: TrustedPartyNew, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return TrustedNetworkApiFp(this.configuration).companyCompanyIdTrustedpartyPost(companyId, trustedPartyNew, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Trusted Party from the trusted network.
     * @summary Del Trusted party
     * @param {string} companyId 
     * @param {string} trustedpartyId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrustedNetworkApi
     */
    public companyCompanyIdTrustedpartyTrustedpartyIdDelete(companyId: string, trustedpartyId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return TrustedNetworkApiFp(this.configuration).companyCompanyIdTrustedpartyTrustedpartyIdDelete(companyId, trustedpartyId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
         * @summary Add Wallet to a fund
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {FundWallet} fundWallet 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWalletPost: async (companyId: string, fundId: string, fundWallet: FundWallet, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdWalletPost', 'companyId', companyId)
            // verify required parameter 'fundId' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdWalletPost', 'fundId', fundId)
            // verify required parameter 'fundWallet' is not null or undefined
            assertParamExists('companyCompanyIdFundFundIdWalletPost', 'fundWallet', fundWallet)
            const localVarPath = `/company/{company_id}/fund/{fund_id}/wallet`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fundWallet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of all identities that can be added as Connected accounts to a wallet.
         * @summary Get list of all available exchanges
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesGet: async (xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update fund wallet withdraw or transfer policy
         * @summary 
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} walletId 
         * @param {UpdateWalletPolicyRequest} [updateWalletPolicyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletPolicy: async (companyId: string, fundId: string, walletId: string, updateWalletPolicyRequest?: UpdateWalletPolicyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateWalletPolicy', 'companyId', companyId)
            // verify required parameter 'fundId' is not null or undefined
            assertParamExists('updateWalletPolicy', 'fundId', fundId)
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('updateWalletPolicy', 'walletId', walletId)
            const localVarPath = `/company/{company_id}/fund/{fund_id}/wallet/{wallet_id}/policy`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"fund_id"}}`, encodeURIComponent(String(fundId)))
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWalletPolicyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get wallet info, addresses and balance.
         * @summary Get wallet info
         * @param {string} walletId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdGet: async (walletId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('walletWalletIdGet', 'walletId', walletId)
            const localVarPath = `/wallet/{wallet_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get wallet history
         * @summary Get wallet history
         * @param {string} walletId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {number} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdHistoryGet: async (walletId: string, xNonce?: string, xTimestamp?: string, xSign?: string, since?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('walletWalletIdHistoryGet', 'walletId', walletId)
            const localVarPath = `/wallet/{wallet_id}/history`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the max amount that can be moved out of the wallet. Set pending=\"1\" to include unauthorized transactions when calculating the available balance
         * @summary Get wallet max amount with fees
         * @param {string} walletId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {number} [pending] 
         * @param {'transfer' | 'withdraw' | 'swap'} [txType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdMaxGet: async (walletId: string, xNonce?: string, xTimestamp?: string, xSign?: string, pending?: number, txType?: 'transfer' | 'withdraw' | 'swap', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('walletWalletIdMaxGet', 'walletId', walletId)
            const localVarPath = `/wallet/{wallet_id}/max`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (pending !== undefined) {
                localVarQueryParameter['pending'] = pending;
            }

            if (txType !== undefined) {
                localVarQueryParameter['tx_type'] = txType;
            }

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
         * @summary Add Wallet to a fund
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {FundWallet} fundWallet 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdFundFundIdWalletPost(companyId: string, fundId: string, fundWallet: FundWallet, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletIDList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of all identities that can be added as Connected accounts to a wallet.
         * @summary Get list of all available exchanges
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exchangesGet(xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exchangesGet(xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update fund wallet withdraw or transfer policy
         * @summary 
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} walletId 
         * @param {UpdateWalletPolicyRequest} [updateWalletPolicyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWalletPolicy(companyId: string, fundId: string, walletId: string, updateWalletPolicyRequest?: UpdateWalletPolicyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWalletPolicy(companyId, fundId, walletId, updateWalletPolicyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get wallet info, addresses and balance.
         * @summary Get wallet info
         * @param {string} walletId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletWalletIdGet(walletId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundWalletInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletWalletIdGet(walletId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get wallet history
         * @summary Get wallet history
         * @param {string} walletId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {number} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletWalletIdHistoryGet(walletId: string, xNonce?: string, xTimestamp?: string, xSign?: string, since?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundWalletHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletWalletIdHistoryGet(walletId, xNonce, xTimestamp, xSign, since, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the max amount that can be moved out of the wallet. Set pending=\"1\" to include unauthorized transactions when calculating the available balance
         * @summary Get wallet max amount with fees
         * @param {string} walletId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {number} [pending] 
         * @param {'transfer' | 'withdraw' | 'swap'} [txType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletWalletIdMaxGet(walletId: string, xNonce?: string, xTimestamp?: string, xSign?: string, pending?: number, txType?: 'transfer' | 'withdraw' | 'swap', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletWalletIdMaxGet(walletId, xNonce, xTimestamp, xSign, pending, txType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletApiFp(configuration)
    return {
        /**
         * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
         * @summary Add Wallet to a fund
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {FundWallet} fundWallet 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdFundFundIdWalletPost(companyId: string, fundId: string, fundWallet: FundWallet, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<WalletIDList> {
            return localVarFp.companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of all identities that can be added as Connected accounts to a wallet.
         * @summary Get list of all available exchanges
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesGet(xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<ExchangesList> {
            return localVarFp.exchangesGet(xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Update fund wallet withdraw or transfer policy
         * @summary 
         * @param {string} companyId 
         * @param {string} fundId 
         * @param {string} walletId 
         * @param {UpdateWalletPolicyRequest} [updateWalletPolicyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletPolicy(companyId: string, fundId: string, walletId: string, updateWalletPolicyRequest?: UpdateWalletPolicyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateWalletPolicy(companyId, fundId, walletId, updateWalletPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get wallet info, addresses and balance.
         * @summary Get wallet info
         * @param {string} walletId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdGet(walletId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<FundWalletInfo> {
            return localVarFp.walletWalletIdGet(walletId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Get wallet history
         * @summary Get wallet history
         * @param {string} walletId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {number} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdHistoryGet(walletId: string, xNonce?: string, xTimestamp?: string, xSign?: string, since?: number, options?: any): AxiosPromise<FundWalletHistory> {
            return localVarFp.walletWalletIdHistoryGet(walletId, xNonce, xTimestamp, xSign, since, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the max amount that can be moved out of the wallet. Set pending=\"1\" to include unauthorized transactions when calculating the available balance
         * @summary Get wallet max amount with fees
         * @param {string} walletId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {number} [pending] 
         * @param {'transfer' | 'withdraw' | 'swap'} [txType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWalletIdMaxGet(walletId: string, xNonce?: string, xTimestamp?: string, xSign?: string, pending?: number, txType?: 'transfer' | 'withdraw' | 'swap', options?: any): AxiosPromise<FeesResponse> {
            return localVarFp.walletWalletIdMaxGet(walletId, xNonce, xTimestamp, xSign, pending, txType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * Add a new Wallet to an existing fund. If Custody groups are blank the default fund cutosdy policy will be used
     * @summary Add Wallet to a fund
     * @param {string} companyId 
     * @param {string} fundId 
     * @param {FundWallet} fundWallet 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public companyCompanyIdFundFundIdWalletPost(companyId: string, fundId: string, fundWallet: FundWallet, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return WalletApiFp(this.configuration).companyCompanyIdFundFundIdWalletPost(companyId, fundId, fundWallet, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of all identities that can be added as Connected accounts to a wallet.
     * @summary Get list of all available exchanges
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public exchangesGet(xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return WalletApiFp(this.configuration).exchangesGet(xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update fund wallet withdraw or transfer policy
     * @summary 
     * @param {string} companyId 
     * @param {string} fundId 
     * @param {string} walletId 
     * @param {UpdateWalletPolicyRequest} [updateWalletPolicyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public updateWalletPolicy(companyId: string, fundId: string, walletId: string, updateWalletPolicyRequest?: UpdateWalletPolicyRequest, options?: AxiosRequestConfig) {
        return WalletApiFp(this.configuration).updateWalletPolicy(companyId, fundId, walletId, updateWalletPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get wallet info, addresses and balance.
     * @summary Get wallet info
     * @param {string} walletId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public walletWalletIdGet(walletId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletWalletIdGet(walletId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get wallet history
     * @summary Get wallet history
     * @param {string} walletId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {number} [since] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public walletWalletIdHistoryGet(walletId: string, xNonce?: string, xTimestamp?: string, xSign?: string, since?: number, options?: AxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletWalletIdHistoryGet(walletId, xNonce, xTimestamp, xSign, since, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the max amount that can be moved out of the wallet. Set pending=\"1\" to include unauthorized transactions when calculating the available balance
     * @summary Get wallet max amount with fees
     * @param {string} walletId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {number} [pending] 
     * @param {'transfer' | 'withdraw' | 'swap'} [txType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public walletWalletIdMaxGet(walletId: string, xNonce?: string, xTimestamp?: string, xSign?: string, pending?: number, txType?: 'transfer' | 'withdraw' | 'swap', options?: AxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletWalletIdMaxGet(walletId, xNonce, xTimestamp, xSign, pending, txType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WithdrawalApi - axios parameter creator
 * @export
 */
export const WithdrawalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiate a withdrawal and set parameters for the transaction. When a withdrawal transaction is created, custodian(s) need to approve it through their Qredo Signing app. (The number of custodian approvals depends on your Transfer Policy settings.)
         * @summary New withdrawal
         * @param {string} companyId 
         * @param {Withdrawal} withdrawal 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdWithdrawPost: async (companyId: string, withdrawal: Withdrawal, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdWithdrawPost', 'companyId', companyId)
            // verify required parameter 'withdrawal' is not null or undefined
            assertParamExists('companyCompanyIdWithdrawPost', 'withdrawal', withdrawal)
            const localVarPath = `/company/{company_id}/withdraw`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawal, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain details on a withdrawal status
         * @summary Get withdrawal status
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdWithdrawTxIdGet: async (companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyCompanyIdWithdrawTxIdGet', 'companyId', companyId)
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('companyCompanyIdWithdrawTxIdGet', 'txId', txId)
            const localVarPath = `/company/{company_id}/withdraw/{tx_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xNonce != null) {
                localVarHeaderParameter['x-nonce'] = String(xNonce);
            }

            if (xTimestamp != null) {
                localVarHeaderParameter['x-timestamp'] = String(xTimestamp);
            }

            if (xSign != null) {
                localVarHeaderParameter['x-sign'] = String(xSign);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalApi - functional programming interface
 * @export
 */
export const WithdrawalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WithdrawalApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiate a withdrawal and set parameters for the transaction. When a withdrawal transaction is created, custodian(s) need to approve it through their Qredo Signing app. (The number of custodian approvals depends on your Transfer Policy settings.)
         * @summary New withdrawal
         * @param {string} companyId 
         * @param {Withdrawal} withdrawal 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdWithdrawPost(companyId: string, withdrawal: Withdrawal, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdWithdrawPost(companyId, withdrawal, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Obtain details on a withdrawal status
         * @summary Get withdrawal status
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyCompanyIdWithdrawTxIdGet(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyCompanyIdWithdrawTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WithdrawalApi - factory interface
 * @export
 */
export const WithdrawalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WithdrawalApiFp(configuration)
    return {
        /**
         * Initiate a withdrawal and set parameters for the transaction. When a withdrawal transaction is created, custodian(s) need to approve it through their Qredo Signing app. (The number of custodian approvals depends on your Transfer Policy settings.)
         * @summary New withdrawal
         * @param {string} companyId 
         * @param {Withdrawal} withdrawal 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdWithdrawPost(companyId: string, withdrawal: Withdrawal, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<TxId> {
            return localVarFp.companyCompanyIdWithdrawPost(companyId, withdrawal, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain details on a withdrawal status
         * @summary Get withdrawal status
         * @param {string} companyId 
         * @param {string} txId 
         * @param {string} [xNonce] 
         * @param {string} [xTimestamp] 
         * @param {string} [xSign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyIdWithdrawTxIdGet(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: any): AxiosPromise<WithdrawalInfo> {
            return localVarFp.companyCompanyIdWithdrawTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithdrawalApi - object-oriented interface
 * @export
 * @class WithdrawalApi
 * @extends {BaseAPI}
 */
export class WithdrawalApi extends BaseAPI {
    /**
     * Initiate a withdrawal and set parameters for the transaction. When a withdrawal transaction is created, custodian(s) need to approve it through their Qredo Signing app. (The number of custodian approvals depends on your Transfer Policy settings.)
     * @summary New withdrawal
     * @param {string} companyId 
     * @param {Withdrawal} withdrawal 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApi
     */
    public companyCompanyIdWithdrawPost(companyId: string, withdrawal: Withdrawal, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return WithdrawalApiFp(this.configuration).companyCompanyIdWithdrawPost(companyId, withdrawal, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtain details on a withdrawal status
     * @summary Get withdrawal status
     * @param {string} companyId 
     * @param {string} txId 
     * @param {string} [xNonce] 
     * @param {string} [xTimestamp] 
     * @param {string} [xSign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApi
     */
    public companyCompanyIdWithdrawTxIdGet(companyId: string, txId: string, xNonce?: string, xTimestamp?: string, xSign?: string, options?: AxiosRequestConfig) {
        return WithdrawalApiFp(this.configuration).companyCompanyIdWithdrawTxIdGet(companyId, txId, xNonce, xTimestamp, xSign, options).then((request) => request(this.axios, this.basePath));
    }
}


